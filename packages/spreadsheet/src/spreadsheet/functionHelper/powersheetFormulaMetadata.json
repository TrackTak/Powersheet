{
  "ARRAYFORMULA": {
    "header": "ARRAYFORMULA",
    "headerDescription": "Enables array arithmetic inside.",
    "type": "Google",
    "parameters": ["array_formula"],
    "codeSyntaxUsage": [
      "ARRAYFORMULA(SUM(IF(A1:A10>5, A1:A10, 0)))",
      "ARRAYFORMULA(A1:C1+A2:C2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ARRAYFORMULA(array_formula)",
        "values": [
          {
            "syntaxName": "array_formula",
            "description": "A range, a mathematical expression using one cell range or multiple ranges of the same size, or a function that returns a result greater than one cell."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FILTER": {
    "header": "FILTER",
    "headerDescription": "Filters the array based on boolean arrays.",
    "type": "Filter",
    "parameters": ["range", "condition1", "[condition2]"],
    "codeSyntaxUsage": [
      "FILTER(A2:B26, A2:A26 > 5, D2:D26 < 10)",
      "FILTER(A2:C5, {TRUE; TRUE; FALSE; TRUE})",
      "FILTER(A2:B10, NOT(ISBLANK(A2:A10)))"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FILTER(range, condition1, [condition2, ...])",
        "values": [
          { "syntaxName": "range", "description": "The data to be filtered." },
          {
            "syntaxName": "condition1",
            "description": "A column or row containing true or false values corresponding to the first column or row of range, or an array formula evaluating to true or false."
          },
          { "syntaxName": "condition2 …", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "condition arguments must have exactly the same length as range.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ARRAY_CONSTRAIN": {
    "header": "ARRAY_CONSTRAIN",
    "headerDescription": "Truncates the array to given dimensions.",
    "type": "Array",
    "parameters": ["input_range", "num_rows", "num_cols"],
    "codeSyntaxUsage": [
      "ARRAY_CONSTRAIN(A1:C10, 2, 3)",
      "ARRAY_CONSTRAIN(SORT(A1:F100, 1, TRUE), 10, 6)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ARRAY_CONSTRAIN(input_range, num_rows, num_cols)",
        "values": [
          {
            "syntaxName": "input_range",
            "description": "The range to be constrained."
          },
          {
            "syntaxName": "num_rows",
            "description": "The number of rows that the result should contain."
          },
          {
            "syntaxName": "num_cols",
            "description": "The number of columns that the result should contain"
          }
        ]
      }
    ],
    "attributes": []
  },
  "DATE": {
    "header": "DATE",
    "headerDescription": "Calculates a date specified by year, month, day, and displays it in the cell's formatting.",
    "type": "Date",
    "parameters": ["year", "month", "day"],
    "codeSyntaxUsage": ["DATE(1969,7,20)", "DATE(A2,B2,C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DATE(year, month, day)",
        "values": [
          {
            "syntaxName": "year",
            "description": "The year component of the date."
          },
          {
            "syntaxName": "month",
            "description": "The month component of the date."
          },
          {
            "syntaxName": "day",
            "description": "The day component of the date."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DATEDIF": {
    "header": "DATEDIF",
    "headerDescription": "Calculates distance between two dates, in provided unit parameter.",
    "type": "Date",
    "parameters": ["start_date", "end_date", "unit"],
    "codeSyntaxUsage": [
      "DATEDIF(DATE(1969, 7, 16), DATE(1969, 7, 24), \"\"D\"\")",
      "DATEDIF(A1, A2, \"\"YM\"\")",
      "DATEDIF(\"\"7/16/1969\"\", \"\"7/24/1969\"\", \"\"Y\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DATEDIF(start_date, end_date, unit)",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "the start date to consider in the calculation. Must be a reference to a cell containing a DATE, a function returning a DATE type or a number."
          },
          {
            "syntaxName": "end_date",
            "description": "the end date to consider in the calculation. Must be a reference to a cell containing a DATE, a function returning a DATE type or a number."
          },
          {
            "syntaxName": "unit",
            "description": "a text abbreviation for unit of time. For example,‘M’  for month. Accepted values are ‘Y’,‘M’,‘D’,‘MD’,‘YM’,‘YD’.                  ‘Y’: the number of whole years between  start_date and end_date.                    ‘M’: the number of whole months between  start_date and end_date.                    ‘D’: the number of days between start_date  and end_date.                    ‘MD’: the number of days between start_date  and end_date after subtracting whole months.                    ‘YM’: the number of whole months between  start_date and end_date after subtracting whole years.                    ‘YD’: the number of days between start_date  and end_date, assuming start_date and end_date were no more than one year apart."
          },
          {
            "syntaxName": "‘Y’: the number of whole years between  start_date and end_date.",
            "description": ""
          },
          {
            "syntaxName": "‘M’: the number of whole months between  start_date and end_date.",
            "description": ""
          },
          {
            "syntaxName": "‘D’: the number of days between start_date  and end_date.",
            "description": ""
          },
          {
            "syntaxName": "‘MD’: the number of days between start_date  and end_date after subtracting whole months.",
            "description": ""
          },
          {
            "syntaxName": "‘YM’: the number of whole months between  start_date and end_date after subtracting whole years.",
            "description": ""
          },
          {
            "syntaxName": "‘YD’: the number of days between start_date  and end_date, assuming start_date and end_date were no more than one year apart.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DATEVALUE": {
    "header": "DATEVALUE",
    "headerDescription": "Interprets string as date.",
    "type": "Date",
    "parameters": ["date_string"],
    "codeSyntaxUsage": [
      "DATEVALUE(\"\"1969-7-20\"\")",
      "DATEVALUE(\"\"7/20/1969\"\")",
      "DATEVALUE(A2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DATEVALUE(date_string)",
        "values": [
          {
            "syntaxName": "date_string",
            "description": "The string representing the date.          Understood formats include any date format that is normally auto-converted when entered, without quotation marks, directly into a cell. Understood formats may depend on region and language settings."
          },
          {
            "syntaxName": "Understood formats include any date format that is normally auto-converted when entered, without quotation marks, directly into a cell. Understood formats may depend on region and language settings.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DAY": {
    "header": "DAY",
    "headerDescription": "Returns the day of the given date value.",
    "type": "Date",
    "parameters": ["date"],
    "codeSyntaxUsage": [
      "DAY(DATE(1969,7,20))",
      "DAY(A2)",
      "DAY(40909)",
      "DAY(\"\"7/20/1969\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DAY(date)",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date from which to extract the day. Must be a reference to a cell containing a date, a function returning a date type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DAYS": {
    "header": "DAYS",
    "headerDescription": "Calculates the difference between two date values.",
    "type": "Date",
    "parameters": ["end_date", "start_date"],
    "codeSyntaxUsage": [
      "DAYS(\"\"7/24/1969\"\", \"\"7/16/1969\"\")  DAYS(“2/28/2016”, “2/28/2017”)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DAYS(end_date,start_date)",
        "values": [
          {
            "syntaxName": "end_date",
            "description": "The end of the date range.  "
          },
          {
            "syntaxName": "start_date",
            "description": "The start of the date range.  "
          }
        ]
      }
    ],
    "attributes": []
  },
  "DAYS360": {
    "header": "DAYS360",
    "headerDescription": "Calculates the difference between two date values in days, in 360-day basis.",
    "type": "Date",
    "parameters": ["start_date", "end_date", "[method]"],
    "codeSyntaxUsage": [
      "DAYS360(DATE(1969,7,16),DATE(1969,7,24),1)",
      "DAYS360(A2,A3)",
      "DAYS360(1,270,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DAYS360(start_date, end_date, [method])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          {
            "syntaxName": "end_date",
            "description": "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          { "syntaxName": "method", "description": "[ OPTIONAL" },
          {
            "syntaxName": "0 indicates the US method",
            "description": "Under the US method, if start_date is the last day of a month, the day of month of start_date is changed to 30 for the purposes of the calculation. Furthermore if end_date is the last day of a month and the day of the month of start_date is earlier than the 30th, end_date is changed to the first day of the month following end_date, otherwise the day of month of end_date is changed to 30."
          },
          {
            "syntaxName": "Any other value indicates the European method",
            "description": "under the European method, any start_date or end_date that falls on the 31st of a month has its day of month changed to 30."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EDATE": {
    "header": "EDATE",
    "headerDescription": "Shifts the given startdate by given number of months.",
    "type": "Date",
    "parameters": ["start_date", "months"],
    "codeSyntaxUsage": [
      "EDATE(DATE(1969,7,20), 1)",
      "EDATE(A2, 1)",
      "EDATE(40909, -2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EDATE(start_date, months)",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The date from which to calculate the result."
          },
          {
            "syntaxName": "months",
            "description": "The number of months before (negative) or after (positive) start_date to calculate."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EOMONTH": {
    "header": "EOMONTH",
    "headerDescription": "Returns the date of the last day of a month which falls months away from the start date.",
    "type": "Date",
    "parameters": ["start_date", "months"],
    "codeSyntaxUsage": [
      "EOMONTH(DATE(1969, 7, 20), 1)",
      "EOMONTH(A2, 1)",
      "EOMONTH(40909, -2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EOMONTH(start_date, months)",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The date from which to calculate the the result."
          },
          {
            "syntaxName": "months",
            "description": "The number of months before (negative) or after (positive) start_date to consider. The last calendar day of the calculated month is returned."
          }
        ]
      }
    ],
    "attributes": []
  },
  "HOUR": {
    "header": "HOUR",
    "headerDescription": "Returns hour component of given time.",
    "type": "Date",
    "parameters": ["time"],
    "codeSyntaxUsage": [
      "HOUR(TIME(11,40,59))",
      "HOUR(A2)",
      "HOUR(40909.0004)",
      "HOUR(\"\"20:49:59\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HOUR(time)",
        "values": [
          {
            "syntaxName": "time",
            "description": "The time from which to calculate the hour component. Must be a reference to a cell containing a date/time, a function returning a date/time type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISOWEEKNUM": {
    "header": "ISOWEEKNUM",
    "headerDescription": "Returns an ISO week number that corresponds to the week of year.",
    "type": "Date",
    "parameters": ["date"],
    "codeSyntaxUsage": [
      "ISOWEEKNUM(DATE(1969, 7, 20))",
      "ISOWEEKNUM(\"\"6/14/2002\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISOWEEKNUM(date)",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date that determines the week number. Must refer to a cell containing a date, number, or function returning a date type."
          }
        ]
      }
    ],
    "attributes": []
  },
  "MINUTE": {
    "header": "MINUTE",
    "headerDescription": "Returns minute component of given time.",
    "type": "Date",
    "parameters": ["time"],
    "codeSyntaxUsage": [
      "MINUTE(TIME(11,40,59))",
      "MINUTE(A2)",
      "MINUTE(40909.0004)",
      "MINUTE(\"\"20:49:59\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MINUTE(time)",
        "values": [
          {
            "syntaxName": "time",
            "description": "The time from which to calculate the minute component. Must be a reference to a cell containing a date/time, a function returning a date/time type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "MONTH": {
    "header": "MONTH",
    "headerDescription": "Returns the month for the given date value.",
    "type": "Date",
    "parameters": ["date"],
    "codeSyntaxUsage": [
      "MONTH(DATE(1969, 7, 20))",
      "MONTH(A2)",
      "MONTH(40909)",
      "MONTH(\"\"7/20/1969\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MONTH(date)",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date from which to extract the month. Must be a reference to a cell containing a date, a function returning a date type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NETWORKDAYS": {
    "header": "NETWORKDAYS",
    "headerDescription": "Returns the number of working days between two given dates.",
    "type": "Date",
    "parameters": ["start_date", "end_date", "[holidays]"],
    "codeSyntaxUsage": [
      "NETWORKDAYS(DATE(1969,7,16),DATE(1969,7,24))",
      "NETWORKDAYS(A2,B2)",
      "NETWORKDAYS(40909,40924)",
      "NETWORKDAYS(40900,40950,{40909,40924})"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NETWORKDAYS(start_date, end_date, [holidays])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The start date of the period from which to calculate the number of net working days."
          },
          {
            "syntaxName": "end_date",
            "description": "The end date of the period from which to calculate the number of net working days."
          },
          { "syntaxName": "holidays", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "The values provided within an array for holidays must be date serial number values, as returned by N or date values, as returned by DATE, DATEVALUE or TO_DATE. Values specified by a range should be standard date values or date serial numbers.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "NETWORKDAYS.INTL": {
    "header": "NETWORKDAYS.INTL",
    "headerDescription": "Returns the number of working days between two given dates.",
    "type": "Date",
    "parameters": ["start_date", "end_date", "[weekend]", "[holidays]"],
    "codeSyntaxUsage": [
      "NETWORKDAYS.INTL(DATE(1969, 7, 16), DATE(1969, 7, 24), 1, A1:A10)",
      "NETWORKDAYS.INTL(DATE(1969, 7, 16), DATE(1969, 7, 24))",
      "NETWORKDAYS.INTL(\"\"12/04/1995\"\", \"\"12/22/1995\"\", 3)",
      "NETWORKDAYS.INTL(\"\"12/04/1995\"\", \"\"12/22/1995\"\", “0000011”)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NETWORKDAYS.INTL(start_date, end_date, [weekend], [holidays])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The start date of the period from which the number of net working days is calculated."
          },
          {
            "syntaxName": "end_date",
            "description": "The end date of the period from which the number of net working days is calculated."
          },
          { "syntaxName": "weekend", "description": "[ OPTIONAL" },
          {
            "syntaxName": "String method: Weekends can be specified using seven 0s and 1s, where the first number in the set represents Monday and the last number is for Sunday. A zero means that the day is a work day, a 1 means that the day is a weekend. For example, “0000011” would mean Saturday and Sunday are weekends.",
            "description": ""
          },
          {
            "syntaxName": "Number method: Instead of using the string method above, a single number can be used. 1 = Saturday/Sunday are weekends, 2 = Sunday/Monday and this pattern repeats until 7 = Friday/Saturday. 11 = Sunday is the only weekend day, 12 = Monday is the only weekend day and this pattern repeats until 17 = Saturday is the only weekend day.",
            "description": ""
          },
          { "syntaxName": "holidays", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "The values provided within an array for holidays must be date serial number values, as returned by N or date values, as returned by DATE, DATEVALUE or TO_DATE. Values specified by a range should be standard date values or date serial numbers.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "NOW": {
    "header": "NOW",
    "headerDescription": "Returns current date + time.",
    "type": "Date",
    "parameters": [],
    "codeSyntaxUsage": ["NOW()"],
    "codeSyntaxElements": [{ "codeSyntax": "NOW()", "values": [] }],
    "attributes": []
  },
  "SECOND": {
    "header": "SECOND",
    "headerDescription": "Returns second component of given time.",
    "type": "Date",
    "parameters": ["time"],
    "codeSyntaxUsage": [
      "SECOND(TIME(11,40,59))",
      "SECOND(A2)",
      "SECOND(40909.0004)",
      "SECOND('20:49:59')"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SECOND(time)",
        "values": [
          {
            "syntaxName": "time",
            "description": "The time from which to calculate the second component. Must be a reference to a cell containing a date/time, a function returning a date/time type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TIME": {
    "header": "TIME",
    "headerDescription": "Calculates time from given hour, minute and second.",
    "type": "Date",
    "parameters": ["hour", "minute", "second"],
    "codeSyntaxUsage": ["TIME(11,40,59)", "TIME(A2,B2,C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TIME(hour, minute, second)",
        "values": [
          {
            "syntaxName": "hour",
            "description": "The hour component of the time."
          },
          {
            "syntaxName": "minute",
            "description": "The minute component of the time."
          },
          {
            "syntaxName": "second",
            "description": "The second component of the time."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TIMEVALUE": {
    "header": "TIMEVALUE",
    "headerDescription": "Interprets string as time.",
    "type": "Date",
    "parameters": ["time_string"],
    "codeSyntaxUsage": [
      "TIMEVALUE(\"\"2:15 PM\"\")",
      "TIMEVALUE(\"\"14:15:30\"\")",
      "TIMEVALUE(\"\"11:59:59.50 PM\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TIMEVALUE(time_string)",
        "values": [
          {
            "syntaxName": "time_string",
            "description": "The string that holds the time representation."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TODAY": {
    "header": "TODAY",
    "headerDescription": "Returns current date.",
    "type": "Date",
    "parameters": [],
    "codeSyntaxUsage": ["TODAY()"],
    "codeSyntaxElements": [{ "codeSyntax": "TODAY()", "values": [] }],
    "attributes": []
  },
  "WEEKDAY": {
    "header": "WEEKDAY",
    "headerDescription": "Computes a number between 1-7 representing the day of week.",
    "type": "Date",
    "parameters": ["date", "[type]"],
    "codeSyntaxUsage": [
      "WEEKDAY(DATE(1969,7,20))",
      "WEEKDAY(A2)",
      "WEEKDAY(40909)",
      "WEEKDAY(40909,3)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "WEEKDAY(date, [type])",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date for which to determine the day of the week. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          {
            "syntaxName": "type",
            "description": "[ OPTIONAL - 1 by default ]"
          },
          {
            "syntaxName": "If type is 1, days are counted from Sunday and the value of Sunday is 1; therefore the value of Saturday is 7.",
            "description": ""
          },
          {
            "syntaxName": "If type is 2, days are counted from Monday and the value of Monday is 1; therefore the value of Sunday is 7.",
            "description": ""
          },
          {
            "syntaxName": "If type is 3, days are counted from Monday and the value of Monday is 0; therefore the value of Sunday is 6.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "WEEKNUM": {
    "header": "WEEKNUM",
    "headerDescription": "Returns a week number that corresponds to the week of year.",
    "type": "Date",
    "parameters": ["date", "[type]"],
    "codeSyntaxUsage": [
      "WEEKNUM(DATE(1969, 7, 20), 1)",
      "WEEKNUM(\"\"12/09/1948\"\", 2)",
      "WEEKNUM(\"\"6/14/2002\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "WEEKNUM(date, [type])",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date that determines the week number. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          { "syntaxName": "type", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "WORKDAY": {
    "header": "WORKDAY",
    "headerDescription": "Returns the working day number of days from start day.",
    "type": "Date",
    "parameters": ["start_date", "num_days", "[holidays]"],
    "codeSyntaxUsage": [
      "WORKDAY(DATE(1969,7,20), 4, A1:A10)",
      "WORKDAY(A2, 10)",
      "WORKDAY(40909, 4, B2:B17)",
      "WORKDAY(40909, 30, {40909,40924})"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "WORKDAY(start_date, num_days, [holidays])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The date from which to begin counting."
          },
          {
            "syntaxName": "num_days",
            "description": "The number of working days to advance from start_date. If negative, counts backwards.          If num_days is not an integer, the decimal part is truncated. That is, WORKDAY(A2,1.9) is equivalent to WORKDAY(A2,1)."
          },
          {
            "syntaxName": "If num_days is not an integer, the decimal part is truncated. That is, WORKDAY(A2,1.9) is equivalent to WORKDAY(A2,1).",
            "description": ""
          },
          { "syntaxName": "holidays", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "The values provided within an array for holidays must be date serial number values, as returned by N or date values, as returned by DATE, DATEVALUE or TO_DATE. Values specified by a range should be standard date values or date serial numbers.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "WORKDAY.INTL": {
    "header": "WORKDAY.INTL",
    "headerDescription": "Returns the working day number of days from start day.",
    "type": "Date",
    "parameters": ["start_date", "num_days", "[weekend]", "[holidays]"],
    "codeSyntaxUsage": [
      "WORKDAY.INTL(DATE(1969, 7, 21), 4, 1, A1:A10)",
      "WORKDAY.INTL(DATE(1995, 8, 13), -2, 2, B1:B10)",
      "WORKDAY.INTL(DATE(1969, 7, 21), 0)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "WORKDAY.INTL(start_date, num_days, [weekend], [holidays])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The date from which to begin counting."
          },
          {
            "syntaxName": "num_days",
            "description": "The number of working days to advance from start_date. If negative, this counts backwards."
          },
          { "syntaxName": "weekend", "description": "[ OPTIONAL" },
          {
            "syntaxName": "String method: Weekends can be specified using seven 0s and 1s, where the first number in the set represents Monday and the last number is for Sunday. A zero means that the day is a work day, a 1 means that the day is a weekend. For example, “0000011” would mean Saturday and Sunday are weekends.",
            "description": ""
          },
          {
            "syntaxName": "Number method: Instead of using the string method above, a single number can be used. 1 = Saturday/Sunday are weekends, 2 = Sunday/Monday and this pattern repeats until 7 = Friday/Saturday. 11 = Sunday is the only weekend day, 12 = Monday is the only weekend day and this pattern repeats until 17 = Saturday is the only weekend day.",
            "description": ""
          },
          { "syntaxName": "holidays", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "YEAR": {
    "header": "YEAR",
    "headerDescription": "Returns the year as a number according to the internal calculation rules.",
    "type": "Date",
    "parameters": ["date"],
    "codeSyntaxUsage": ["YEAR(DATE(1969,7,20))", "YEAR(A2)", "YEAR(40909)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "YEAR(date)",
        "values": [
          {
            "syntaxName": "date",
            "description": "The date from which to calculate the year. Must be a cell reference to a cell containing a date, a function returning a date type or a number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "YEARFRAC": {
    "header": "YEARFRAC",
    "headerDescription": "Computes the difference between two date values, in fraction of years.",
    "type": "Date",
    "parameters": ["start_date", "end_date", "[day_count_convention]"],
    "codeSyntaxUsage": [
      "YEARFRAC(DATE(1969,7,16),DATE(1969,7,24),1)",
      "YEARFRAC(A2,A3)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "YEARFRAC(start_date, end_date, [day_count_convention])",
        "values": [
          {
            "syntaxName": "start_date",
            "description": "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          {
            "syntaxName": "end_date",
            "description": "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type or a number."
          },
          { "syntaxName": "day_count_convention", "description": "[ OPTIONAL" },
          {
            "syntaxName": "0 indicates US (NASD) 30/360",
            "description": "This assumes 30-day months and 360-day years as per the National Association of Securities Dealers standard and performs specific adjustments to entered dates which fall at the end of months."
          },
          {
            "syntaxName": "1 indicates Actual/Actual",
            "description": "This calculates based upon the actual number of days between the specified dates and the actual number of days in the intervening years. Used for US Treasury bonds and bills, but also the most relevant for non-financial use."
          },
          {
            "syntaxName": "2 indicates Actual/360",
            "description": "This calculates based on the actual number of days between the specified dates but assumes a 360-day year."
          },
          {
            "syntaxName": "3 indicates Actual/365",
            "description": "This calculates based on the actual number of days between the specified dates but assumes a 365-day year."
          },
          {
            "syntaxName": "4 indicates European 30/360",
            "description": "Similar to 0, this calculates based on a 30-day month and 360-day year but adjusts end-of-month dates according to European financial conventions."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BIN2DEC": {
    "header": "BIN2DEC",
    "headerDescription": "The result is the decimal number for the binary number entered.",
    "type": "Engineering",
    "parameters": ["signed_binary_number"],
    "codeSyntaxUsage": ["BIN2DEC(101)", "BIN2DEC(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BIN2DEC(signed_binary_number)",
        "values": [
          {
            "syntaxName": "signed_binary_number",
            "description": "The signed 10-bit binary value to be converted to decimal, provided as a string.                  The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, the input value has a maximum of 0111111111 if positive, and a minimum of 1000000000 if negative.                    If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2DEC(100) and BIN2DEC(\"\"100\"\") yield the same result: 4."
          },
          {
            "syntaxName": "The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, the input value has a maximum of 0111111111 if positive, and a minimum of 1000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2DEC(100) and BIN2DEC(\"\"100\"\") yield the same result: 4.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "BIN2HEX": {
    "header": "BIN2HEX",
    "headerDescription": "The result is the hexadecimal number for the binary number entered.",
    "type": "Engineering",
    "parameters": ["signed_binary_number", "[significant_digits]"],
    "codeSyntaxUsage": ["BIN2HEX(101,8)", "BIN2HEX(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BIN2HEX(signed_binary_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_binary_number",
            "description": "The signed 10-bit binary value to be converted to signed hexadecimal, provided as a string.                  The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 0111111111 if positive and a minimum of 1000000000 if negative.                    If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2HEX(11111) and BIN2HEX('11111') yield the same result: 1F."
          },
          {
            "syntaxName": "The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 0111111111 if positive and a minimum of 1000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2HEX(11111) and BIN2HEX('11111') yield the same result: 1F.",
            "description": ""
          },
          { "syntaxName": "significant_digits", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits. For example, BIN2HEX('11111',8) yields the value 0000001F.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_binary_number is 1; that is, if the expressed signed_binary_number is greater than or equal to 1000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "BIN2OCT": {
    "header": "BIN2OCT",
    "headerDescription": "The result is the octal number for the binary number entered.",
    "type": "Engineering",
    "parameters": ["signed_binary_number", "[significant_digits]"],
    "codeSyntaxUsage": ["BIN2OCT(101,8)", "BIN2OCT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BIN2OCT(signed_binary_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_binary_number",
            "description": "The signed 10-bit binary value to be converted to signed octal, provided as a string.                  The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 0111111111 if positive and a minimum of 1000000000 if negative.                    If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2OCT(11111) and BIN2OCT(\"\"11111\"\") yield the same result: 37."
          },
          {
            "syntaxName": "The most significant bit of signed_binary_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 0111111111 if positive and a minimum of 1000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_binary_number is provided as a valid binary number, it will automatically be converted to the appropriate string input. For example, BIN2OCT(11111) and BIN2OCT(\"\"11111\"\") yield the same result: 37.",
            "description": ""
          },
          { "syntaxName": "significant_digits", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits. For example, BIN2OCT(\"\"11111\"\") yields the value 00000037.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_binary_number is 1; that is, if the expressed signed_binary_number is greater than or equal to 1000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "BITAND": {
    "header": "BITAND",
    "headerDescription": "Returns a bitwise logical \"and\" of the parameters.",
    "type": "Engineering",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BITAND(value1,value2)",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first number. Must be the decimal representation of the number."
          },
          {
            "syntaxName": "value2",
            "description": "The second number. Must be the decimal representation of the number."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BITLSHIFT": {
    "header": "BITLSHIFT",
    "headerDescription": "Shifts a number left by n bits.",
    "type": "Engineering",
    "parameters": ["value", "shift_amount"],
    "codeSyntaxUsage": ["BITLSHIFT(9, 2)  BITLSHIFT(A2, 4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BITLSHIFT(value,shift_amount)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number to be shifted. Must be a non-negative number."
          },
          {
            "syntaxName": "shift_amount",
            "description": "The number of places to shift by. Must be a value between -53 and 53, inclusive. Supplying a negative value will effectively be a BITRSHIFT."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BITOR": {
    "header": "BITOR",
    "headerDescription": "Returns a bitwise logical \"or\" of the parameters.",
    "type": "Engineering",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["BITOR(9, 5)", "BITOR(A1, 10)", "BITOR(A1, B1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BITOR(value1, value2)",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first number.               The given value must be a decimal representation of the number.            "
          },
          {
            "syntaxName": "value2",
            "description": "The second number.               The given value must be a decimal representation of the number.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "BITRSHIFT": {
    "header": "BITRSHIFT",
    "headerDescription": "Shifts a number right by n bits.",
    "type": "Engineering",
    "parameters": ["value", "shift_amount"],
    "codeSyntaxUsage": ["BITRSHIFT(18, 2)", "BITRSHIFT(A2, 4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BITRSHIFT(value, shift_amount)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number to be shifted.               The given value must be a non-negative number.            "
          },
          {
            "syntaxName": "shift_amount",
            "description": "The number of places to shift the given value.               The given number must be a number from -52 to 53.        Entering a negative value is effectively a BITLSHIFT function.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "BITXOR": {
    "header": "BITXOR",
    "headerDescription": "Returns a bitwise logical \"exclusive or\" of the parameters.",
    "type": "Engineering",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["BITXOR(9, 5)", "BITXOR(A1, A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BITXOR(value1, value2)",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first numerical value.  "
          },
          {
            "syntaxName": "value2",
            "description": "The second numerical value.  "
          }
        ]
      }
    ],
    "attributes": []
  },
  "COMPLEX": {
    "header": "COMPLEX",
    "headerDescription": "Returns complex number from Re and Im parts.",
    "type": "Engineering",
    "parameters": ["real_part", "imaginary_part", "[suffix]"],
    "codeSyntaxUsage": [
      "COMPLEX(3, 4)",
      "COMPLEX(3, -1, \"\"j\"\")",
      "COMPLEX(3, 0)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COMPLEX(real_part, imaginary_part, [suffix])",
        "values": [
          {
            "syntaxName": "real_part - The real coefficient.",
            "description": ""
          },
          {
            "syntaxName": "imaginary_part - The imaginary coefficient.",
            "description": ""
          },
          {
            "syntaxName": "suffix - [ OPTIONAL 'i' by default] The suffix for the imaginary coefficient.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DEC2BIN": {
    "header": "DEC2BIN",
    "headerDescription": "Returns the binary number for the decimal number entered between –512 and 511.",
    "type": "Engineering",
    "parameters": ["decimal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["DEC2BIN(\"\"100\"\",8)", "DEC2BIN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DEC2BIN(decimal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "decimal_number",
            "description": "The decimal value to be converted to signed binary, provided as a string.                  For this function, this value has a maximum of 511 if positive, and a minimum of -512 if negative.                    If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2BIN(199) and DEC2BIN(\"\"199\"\") yield the same result: 11000111."
          },
          {
            "syntaxName": "For this function, this value has a maximum of 511 if positive, and a minimum of -512 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2BIN(199) and DEC2BIN(\"\"199\"\") yield the same result: 11000111.",
            "description": ""
          },
          {
            "syntaxName": "significant_digits",
            "description": "[ OPTIONAL ] The number of significant digits to ensure in the result.                  If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    This value is ignored if decimal_number is negative."
          },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if decimal_number is negative.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DEC2HEX": {
    "header": "DEC2HEX",
    "headerDescription": "Returns the hexadecimal number for the decimal number entered.",
    "type": "Engineering",
    "parameters": ["decimal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["DEC2HEX(100,8)", "DEC2HEX(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DEC2HEX(decimal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "decimal_number",
            "description": "The decimal value to be converted to signed hexadecimal, provided as a string.                  For this function, this value has a maximum of 549755813887 if positive, and a minimum of -549755813888 if negative.                    If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2HEX(100) and DEC2HEX(\"\"100\"\") yield the same result: 64."
          },
          {
            "syntaxName": "For this function, this value has a maximum of 549755813887 if positive, and a minimum of -549755813888 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2HEX(100) and DEC2HEX(\"\"100\"\") yield the same result: 64.",
            "description": ""
          },
          { "syntaxName": "significant_digits", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if decimal_number is negative.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DEC2OCT": {
    "header": "DEC2OCT",
    "headerDescription": "Returns the octal number for the decimal number entered.",
    "type": "Engineering",
    "parameters": ["decimal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["DEC2OCT('100',8)", "DEC2OCT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DEC2OCT(decimal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "decimal_number",
            "description": "The decimal value to be converted to signed octal, provided as a string.                  For this function, this value has a maximum of 536870911 if positive and a minimum of -53687092 if negative.                    If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2OCT(199) and DEC2OCT('199') yield the same result: 307."
          },
          {
            "syntaxName": "For this function, this value has a maximum of 536870911 if positive and a minimum of -53687092 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If decimal_number is provided as a valid decimal number, it will automatically be converted to the appropriate string input. For example, DEC2OCT(199) and DEC2OCT('199') yield the same result: 307.",
            "description": ""
          },
          {
            "syntaxName": "significant_digits",
            "description": "[ OPTIONAL ] The number of significant digits to ensure in the result.                  If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    This value is ignored if decimal_number is negative."
          },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if decimal_number is negative.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "DELTA": {
    "header": "DELTA",
    "headerDescription": "Returns TRUE (1) if both numbers are equal, otherwise returns FALSE (0).",
    "type": "Engineering",
    "parameters": ["number1", "[number2]"],
    "codeSyntaxUsage": ["DELTA(2, 1)", "DELTA(A2)", "DELTA(B3, 2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DELTA(number1, [number2])",
        "values": [
          {
            "syntaxName": "number1",
            "description": "the first number to compare."
          },
          { "syntaxName": "number2", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "ERF": {
    "header": "ERF",
    "headerDescription": "Returns values of the Gaussian error integral.",
    "type": "Engineering",
    "parameters": ["lower_bound", "[upper_bound]"],
    "codeSyntaxUsage": ["ERF(-2.3, -0.7)", "ERF(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ERF(lower_bound, [upper_bound])",
        "values": [
          {
            "syntaxName": "lower_bound",
            "description": "If this is the only parameter, the integral is taken between 0 and this value. If z2 is provided, it refers to the lower boundary for the integral.  "
          },
          {
            "syntaxName": "upper_bound",
            "description": "The upper boundary of the integral. Upper boundaries are optional."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ERFC": {
    "header": "ERFC",
    "headerDescription": "Returns complementary values of the Gaussian error integral between x and infinity.",
    "type": "Math",
    "parameters": ["z"],
    "codeSyntaxUsage": ["ERFC(2)", "ERFC(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ERFC(z)",
        "values": [
          {
            "syntaxName": "z",
            "description": "The number for which the complementary Gauss error function is calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "HEX2BIN": {
    "header": "HEX2BIN",
    "headerDescription": "The result is the binary number for the hexadecimal number entered.",
    "type": "Engineering",
    "parameters": ["signed_hexadecimal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["HEX2BIN('f3',8)", "HEX2BIN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HEX2BIN(signed_hexadecimal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_hexadecimal_number",
            "description": "The signed 40-bit hexadecimal value to be converted to signed binary, provided as a string.                  The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 1FF if positive and a minimum of FFFFFFFE00 if negative.                    If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2BIN(199) and HEX2BIN('199') yield the same result: 110011001."
          },
          {
            "syntaxName": "The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 1FF if positive and a minimum of FFFFFFFE00 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2BIN(199) and HEX2BIN('199') yield the same result: 110011001.",
            "description": ""
          },
          {
            "syntaxName": "significant_digits",
            "description": "[ OPTIONAL ] The number of significant digits to ensure in the result.                  If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    This value is ignored if the most significant bit of signed_hexadecimal_number is 1; that is, if the expressed signed_hexadecimal_number is greater than or equal to 8000000000."
          },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_hexadecimal_number is 1; that is, if the expressed signed_hexadecimal_number is greater than or equal to 8000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "HEX2DEC": {
    "header": "HEX2DEC",
    "headerDescription": "The result is the decimal number for the hexadecimal number entered.",
    "type": "Engineering",
    "parameters": ["signed_hexadecimal_number"],
    "codeSyntaxUsage": ["HEX2DEC(\"\"f3\"\")", "HEX2DEC(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HEX2DEC(signed_hexadecimal_number)",
        "values": [
          {
            "syntaxName": "signed_hexadecimal_number",
            "description": "The signed 40-bit hexadecimal value to be converted to decimal, provided as a string.                  The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 7fffffffff if positive, and a minimum of 8000000000 if negative.                    If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2DEC(199) and HEX2DEC(\"\"199\"\") yield the same result: 409."
          },
          {
            "syntaxName": "The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 7fffffffff if positive, and a minimum of 8000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2DEC(199) and HEX2DEC(\"\"199\"\") yield the same result: 409.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "HEX2OCT": {
    "header": "HEX2OCT",
    "headerDescription": "The result is the octal number for the hexadecimal number entered.",
    "type": "Engineering",
    "parameters": ["signed_hexadecimal_number", "significant_digits"],
    "codeSyntaxUsage": ["HEX2OCT('f3',8)", "HEX2OCT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HEX2OCT(signed_hexadecimal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_hexadecimal_number",
            "description": "The signed 40-bit hexadecimal value to be converted to signed octal, provided as a string.                  The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 1FFFFFFF if positive and a minimum of FFE0000000 if negative.                    If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2OCT(199) and HEX2OCT(\"\"199\"\") yield the same result: 631."
          },
          {
            "syntaxName": "The most significant bit of signed_hexadecimal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 1FFFFFFF if positive and a minimum of FFE0000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_hexadecimal_number is provided as a valid hexadecimal number, it will automatically be converted to the appropriate string input. For example, HEX2OCT(199) and HEX2OCT(\"\"199\"\") yield the same result: 631.",
            "description": ""
          },
          {
            "syntaxName": "significant_digits",
            "description": "[ OPTIONAL ] The number of significant digits to ensure in the result.                  If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    This value is ignored if the most significant bit of signed_hexadecimal_number is 1; that is, if the expressed signed_hexadecimal_number is greater than or equal to 8000000000."
          },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_hexadecimal_number is 1; that is, if the expressed signed_hexadecimal_number is greater than or equal to 8000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMABS": {
    "header": "IMABS",
    "headerDescription": "Returns module of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMABS(\"\"3+4i\"\")", "IMABS(\"\"6j\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMABS(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number of which to calculate the absolute value."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMAGINARY": {
    "header": "IMAGINARY",
    "headerDescription": "Returns imaginary part of a complex number.",
    "type": "Engineering",
    "parameters": ["complex_number"],
    "codeSyntaxUsage": ["IMAGINARY(\"\"4+5i\"\")", "IMAGINARY(\"\"2j\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMAGINARY(complex_number)",
        "values": [
          {
            "syntaxName": "complex_number - The complex number, in the a+bi or a+bj format.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMARGUMENT": {
    "header": "IMARGUMENT",
    "headerDescription": "Returns argument of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMARGUMENT(COMPLEX(4, 6)",
      "IMARGUMENT(4)",
      "IMARGUMENT(\"\"2+3I\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "=IMARGUMENT(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number the argument of which will be calculated.       This can be either the result of the COMPLEX function, a real number (which is interpreted as a complex number with imaginary part equal to 0)  or a string in the format “x + yi” where x and y are numeric.      "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCONJUGATE": {
    "header": "IMCONJUGATE",
    "headerDescription": "Returns conjugate of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMCONJUGATE(\"\"3+4i\"\")",
      "IMCONJUGATE(\"\"-2i\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCONJUGATE(number)",
        "values": [
          {
            "syntaxName": "number - The complex number to calculate the conjugate for.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCOS": {
    "header": "IMCOS",
    "headerDescription": "Returns cosine of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMCOS(COMPLEX(4, 6))",
      "IMCOS(4)",
      "IMCOS(\"\"2+3i\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCOS(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the cosine. This can be either the result of the COMPLEX function, a real number (which will be interpreted as a complex number with imaginary part equal to 0) or a string in the format “x+yi” where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCOSH": {
    "header": "IMCOSH",
    "headerDescription": "Returns hyperbolic cosine of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMCOSH(COMPLEX(4, 6))", "IMCOSH(4)", "IMCOSH('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCOSH(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the hyperbolic cosine. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCOT": {
    "header": "IMCOT",
    "headerDescription": "Returns cotangens of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMCOT(COMPLEX(4,6))", "IMCOT(4)", "IMCOT('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCOT(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the cotangent. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCSC": {
    "header": "IMCSC",
    "headerDescription": "Returns cosecans of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMCSC(COMPLEX(4, 6))",
      "IMCSC(4)",
      "IMCSC(\"\"2+3i\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCSC(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the cosecant. This can be either the result of the COMPLEX function, a real number (which will be interpreted as a complex number with imaginary part equal to 0), or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMCSCH": {
    "header": "IMCSCH",
    "headerDescription": "Returns hyperbolic cosecans of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMCSCH(COMPLEX(4,6))", "IMCSCH(4)", "IMCSCH('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMCSCH(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the hyperbolic cosecant. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMDIV": {
    "header": "IMDIV",
    "headerDescription": "Divides two complex numbers.",
    "type": "Engineering",
    "parameters": ["dividend", "divisor"],
    "codeSyntaxUsage": [
      "IMDIV(\"\"11+16i\"\", \"\"3+2i\"\")",
      "IMDIV(\"\"4+2j\"\", 2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMDIV(dividend, divisor)",
        "values": [
          {
            "syntaxName": "dividend - The complex number to be divided.",
            "description": ""
          },
          {
            "syntaxName": "divisor - The complex number to divide by.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMEXP": {
    "header": "IMEXP",
    "headerDescription": "Returns exponent of a complex number.",
    "type": "Engineering",
    "parameters": ["exponent"],
    "codeSyntaxUsage": [
      "IMEXP(\"\"2+3i\"\")",
      "IMEXP(\"\"2-4j\"\")",
      "IMEXP(COMPLEX(2, 3))"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMEXP(exponent)",
        "values": [
          {
            "syntaxName": "exponent",
            "description": "The exponent to raise e to."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMLN": {
    "header": "IMLN",
    "headerDescription": "Returns natural logarithm of a complex number.",
    "type": "Math",
    "parameters": ["complex_value"],
    "codeSyntaxUsage": ["IMLN(\"\"3+4i\"\")", "IMLN(A2)", "IMLN(\"\"4+2j\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "The IMLN formula is formatted as =IIMLN(number).",
        "values": [
          {
            "syntaxName": "number",
            "description": "The input value of the logarithm function.               The number can be written as plain numbers, e.g. 1, to be interpreted as a real number.        The number can be written as quoted text in order to specify both the real and complex coefficients.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMLOG2": {
    "header": "IMLOG2",
    "headerDescription": "Returns binary logarithm of a complex number.",
    "type": "Engineering",
    "parameters": ["value"],
    "codeSyntaxUsage": [
      "IMLOG2('1+i', 3.5)",
      "IMLOG2(COMPLEX(25, 34), 2.3)",
      "IMLOG2(100, 10)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMLOG2(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The input value of the logarithm function.               The number can be written as plain numbers, for example 1, to be interpreted as a real number.        The number can be written as quoted text in order to specify both the real and complex coefficients.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMLOG10": {
    "header": "IMLOG10",
    "headerDescription": "Returns base-10 logarithm of a complex number.",
    "type": "Engineering",
    "parameters": ["value"],
    "codeSyntaxUsage": [
      "IMLOG10('1+i', 3.5)",
      "IMLOG10(COMPLEX(25, 34), 2.3)",
      "IMLOG10(100, 10)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMLOG10(value)",
        "values": [
          {
            "syntaxName": "Value",
            "description": "The input value of the logarithm function.               The number can be written as plain numbers, for example 1, to be interpreted as a real number.        The number can be written as quoted text in order to specify both the real and complex coefficients.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMPOWER": {
    "header": "IMPOWER",
    "headerDescription": "Returns a complex number raised to a given power.",
    "type": "Math",
    "parameters": ["complex_base", "exponent"],
    "codeSyntaxUsage": [
      "IMPOWER(\"\"4-3i\"\",0.5)",
      "IMPOWER(A2,B2)",
      "IMPOWER(\"\"2j\"\",-7)",
      ""
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "The IMPOWER formula is formatted as =IMPOWER(complex_base, exponent).",
        "values": [
          {
            "syntaxName": "complex_base",
            "description": "The complex number to be raised to the exponent power.               May be written as a ∓ bi or a ∓ bj.            "
          },
          {
            "syntaxName": "exponent",
            "description": "The exponent to raise complex_base to.               Must be a number.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMPRODUCT": {
    "header": "IMPRODUCT",
    "headerDescription": "Multiplies complex numbers.",
    "type": "Engineering",
    "parameters": ["factor1", "[factor2, ..]"],
    "codeSyntaxUsage": [
      "IMPRODUCT(A2:A100)",
      "IMPRODUCT(\"\"1+2i\"\",3,\"\"4i\"\")",
      "IMPRODUCT(\"\"1+2i\"\",\"\"3+5i\"\",A2:A50)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMPRODUCT(factor1, [factor2, ...])",
        "values": [
          {
            "syntaxName": "factor1 - The first complex number or range to calculate for the product.",
            "description": ""
          },
          {
            "syntaxName": "factor2, ... - [ OPTIONAL ] - More complex numbers to multiply by.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMREAL": {
    "header": "IMREAL",
    "headerDescription": "Returns real part of a complex number.",
    "type": "Engineering",
    "parameters": ["complex_number"],
    "codeSyntaxUsage": ["IMREAL(\"\"4+5i\"\")", "IMREAL(\"\"4j\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMREAL(complex_number)",
        "values": [
          {
            "syntaxName": "complex_number",
            "description": "The complex number, in the a+bi or a+bj format."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSEC": {
    "header": "IMSEC",
    "headerDescription": "Returns secans of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMSEC(COMPLEX(4,6))", "IMSEC(4)", "IMSEC('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSEC(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the secant. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSECH": {
    "header": "IMSECH",
    "headerDescription": "Returns hyperbolic secans of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMSECH(COMPLEX(4,6))", "IMSECH(4)", "IMSECH('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSECH(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the hyperbolic secant. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSIN": {
    "header": "IMSIN",
    "headerDescription": "Returns sine of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMSIN(COMPLEX(4,6))",
      "IMSIN(4)",
      "IMSIN(\"\"2+3i\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSIN (number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the sine.       This can be either the result of the COMPLEX function, a real number (which will be interpreted as a complex number with imaginary part equal to 0) or a string in the format \"\"x+ yi\"\" where x and y are numeric.       "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSINH": {
    "header": "IMSINH",
    "headerDescription": "Returns hyperbolic sine of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": ["IMSINH(COMPLEX(4,6))", "IMSINH(4)", "IMSINH('2+3i')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSINH(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the hyperbolic sine. This can be either the result of the COMPLEX function, a real number interpreted as a complex number with imaginary parts equal to 0 or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSQRT": {
    "header": "IMSQRT",
    "headerDescription": "Returns a square root of a complex number.",
    "type": "Math",
    "parameters": ["complex_number"],
    "codeSyntaxUsage": ["IMSQRT(2)", "IMSQRT(\"\"3+2i\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "The IMSQRT formula is formatted as =IMSQRT(complex_number).",
        "values": [
          {
            "syntaxName": "complex_number",
            "description": "The complex number to take the square root of.  "
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSUB": {
    "header": "IMSUB",
    "headerDescription": "Subtracts two complex numbers.",
    "type": "Engineering",
    "parameters": ["first_number", "second_number"],
    "codeSyntaxUsage": ["IMSUB(\"\"6+5i\"\", \"\"2+3i\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSUB(first_number, second_number)",
        "values": [
          {
            "syntaxName": "first_number - The complex number to subtract second_number from.",
            "description": ""
          },
          {
            "syntaxName": "second_number - The complex number to subtract from first_number.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMSUM": {
    "header": "IMSUM",
    "headerDescription": "Adds complex numbers.",
    "type": "Engineering",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "IMSUM(A2:A100)",
      "IMSUM(\"\"1+2i\"\",3,\"\"4i\"\")",
      "IMSUM(\"\"1+2i\"\",\"\"3+5i\"\",A2:A50)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMSUM(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first complex number or range to add together."
          },
          {
            "syntaxName": "value2, … - [ OPTIONAL ]",
            "description": "More complex numbers or ranges to add to value1."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IMTAN": {
    "header": "IMTAN",
    "headerDescription": "Returns tangens of a complex number.",
    "type": "Engineering",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "IMTAN(COMPLEX(4, 6))",
      "IMTAN(4)",
      "IMTAN(\"\"2+3i\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IMTAN(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The complex number for which you want the tangent. This can be either the result of the COMPLEX function, a real number (which will be interpreted as a complex number with an imaginary part equal to 0), or a string in the format 'x+yi' where x and y are numeric."
          }
        ]
      }
    ],
    "attributes": []
  },
  "OCT2BIN": {
    "header": "OCT2BIN",
    "headerDescription": "The result is the binary number for the octal number entered.",
    "type": "Engineering",
    "parameters": ["signed_octal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["OCT2BIN(37,8)", "OCT2BIN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "OCT2BIN(signed_octal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_octal_number",
            "description": "The signed 30-bit octal value to be converted to signed binary, provided as a string.                  The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 777 if positive, and a minimum of 7777777000 if negative.                    If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2BIN(177) and OCT2BIN('177') yield the same result: 1111111."
          },
          {
            "syntaxName": "The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 777 if positive, and a minimum of 7777777000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2BIN(177) and OCT2BIN('177') yield the same result: 1111111.",
            "description": ""
          },
          {
            "syntaxName": "significant_digits",
            "description": "[ OPTIONAL ] The number of significant digits to ensure in the result.                  If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    This value is ignored if the most significant bit of signed_octal_number is 1; that is, if the expressed signed_octal_number is greater than or equal to 4000000000."
          },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_octal_number is 1; that is, if the expressed signed_octal_number is greater than or equal to 4000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "OCT2DEC": {
    "header": "OCT2DEC",
    "headerDescription": "The result is the decimal number for the octal number entered.",
    "type": "Engineering",
    "parameters": ["signed_octal_number"],
    "codeSyntaxUsage": ["OCT2DEC(37)", "OCT2DEC(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "OCT2DEC(signed_octal_number)",
        "values": [
          {
            "syntaxName": "signed_octal_number - The signed 30-bit octal value to be converted to decimal, provided as a string.                  The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 3777777777 if positive and a minimum of 4000000000 if negative.                    If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2DEC(177) and OCT2DEC('177') yield the same result: 127.",
            "description": ""
          },
          {
            "syntaxName": "The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 3777777777 if positive and a minimum of 4000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2DEC(177) and OCT2DEC('177') yield the same result: 127.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "OCT2HEX": {
    "header": "OCT2HEX",
    "headerDescription": "The result is the hexadecimal number for the octal number entered.",
    "type": "Engineering",
    "parameters": ["signed_octal_number", "[significant_digits]"],
    "codeSyntaxUsage": ["OCT2HEX(37,8)", "OCT2HEX(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "OCT2HEX(signed_octal_number, [significant_digits])",
        "values": [
          {
            "syntaxName": "signed_octal_number",
            "description": "The signed 30-bit octal value to be converted to signed hexadecimal, provided as a string.                  The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.                    For this function, this value has a maximum of 3777777777 if positive and a minimum of 4000000000 if negative.                    If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2HEX(177) and OCT2HEX('177') yield the same result: 7F."
          },
          {
            "syntaxName": "The most significant bit of signed_octal_number is the sign bit; that is, negative numbers are represented in two's complement format.",
            "description": ""
          },
          {
            "syntaxName": "For this function, this value has a maximum of 3777777777 if positive and a minimum of 4000000000 if negative.",
            "description": ""
          },
          {
            "syntaxName": "If signed_octal_number is provided as a valid octal number, it will automatically be converted to the appropriate string input. For example, OCT2HEX(177) and OCT2HEX('177') yield the same result: 7F.",
            "description": ""
          },
          { "syntaxName": "significant_digits", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "If this is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.",
            "description": ""
          },
          {
            "syntaxName": "This value is ignored if the most significant bit of signed_octal_number is 1; that is, if the expressed signed_octal_number is greater than or equal to 4000000000.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISBLANK": {
    "header": "ISBLANK",
    "headerDescription": "Returns TRUE if the reference to a cell is blank.",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISBLANK(A2)", "IF(ISBLANK(B1),,A1/B1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISBLANK(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Reference to the cell that will be checked for emptiness.          ISBLANK returns TRUE if value is empty or a reference to an empty cell, and FALSE if it contains data or a reference to data."
          },
          {
            "syntaxName": "ISBLANK returns TRUE if value is empty or a reference to an empty cell, and FALSE if it contains data or a reference to data.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISERR": {
    "header": "ISERR",
    "headerDescription": "Returns TRUE if the value is error value except ",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISERR(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISERR(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as an error type other than #N/A.          ISERR returns TRUE if value is any error other than #N/A, including #DIV/0!, #NAME?, #NULL!, #NUM!, #VALUE! and #REF!. This is useful in certain applications where #N/A may be a valid outcome, whereas the other error types always indicate a fundamental problem."
          },
          {
            "syntaxName": "ISERR returns TRUE if value is any error other than #N/A, including #DIV/0!, #NAME?, #NULL!, #NUM!, #VALUE! and #REF!. This is useful in certain applications where #N/A may be a valid outcome, whereas the other error types always indicate a fundamental problem.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISERROR": {
    "header": "ISERROR",
    "headerDescription": "Returns TRUE if the value is general error value.",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": [
      "ISERROR(A2)",
      "ISERROR(A1/A2)",
      "IF(ISERROR(VLOOKUP(B1, A1:A100, 1, FALSE)), 'Result not found', VLOOKUP(B1, A1:A100, 1, FALSE))"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISERROR(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as an error type.          ISERROR returns TRUE if value is any error, including #DIV/0!, #N/A, #NAME?,#NULL!, #NUM!, #VALUE! and #REF!."
          },
          {
            "syntaxName": "ISERROR returns TRUE if value is any error, including #DIV/0!, #N/A, #NAME?,#NULL!, #NUM!, #VALUE! and #REF!.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISEVEN": {
    "header": "ISEVEN",
    "headerDescription": "Returns TRUE if the value is an even integer, or FALSE if the value is odd.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISEVEN(4)", "ISEVEN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISEVEN(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as even.          ISEVEN returns TRUE if value is an even integer or a reference to a cell containing an even integer, and FALSE otherwise."
          },
          {
            "syntaxName": "ISEVEN returns TRUE if value is an even integer or a reference to a cell containing an even integer, and FALSE otherwise.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISFORMULA": {
    "header": "ISFORMULA",
    "headerDescription": "Checks whether referenced cell is a formula.",
    "type": "Info",
    "parameters": ["cell"],
    "codeSyntaxUsage": ["ISFORMULA(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISFORMULA(cell)",
        "values": [
          {
            "syntaxName": "cell",
            "description": "The cell to check for a formula.          ISFORMULA returns TRUE if cell is a cell that contains a formula. If cell contains a range of cells then TRUE will be returned if the first cell in the range contains a formula. All other values will return FALSE."
          },
          {
            "syntaxName": "ISFORMULA returns TRUE if cell is a cell that contains a formula. If cell contains a range of cells then TRUE will be returned if the first cell in the range contains a formula. All other values will return FALSE.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISLOGICAL": {
    "header": "ISLOGICAL",
    "headerDescription": "Tests for a logical value (TRUE or FALSE).",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISLOGICAL(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISLOGICAL(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as a logical TRUE or FALSE.    *ISLOGICAL returns TRUE if value is either TRUE or FALSE or a reference to a cell whose value is either TRUE or FALSE."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISNA": {
    "header": "ISNA",
    "headerDescription": "Returns TRUE if the value is ",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISNA(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISNA(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be compared with the error value #N/A.    *ISNA returns TRUE if value is #N/A or a reference to a cell containing #N/A and false otherwise."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISNONTEXT": {
    "header": "ISNONTEXT",
    "headerDescription": "Tests if the cell contents are text or numbers, and returns FALSE if the contents are text.",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISNONTEXT(A2)", "ISNONTEXT('cat')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISNONTEXT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The text to be checked.                  ISNONTEXT returns FALSE if this is a text value or a reference to a cell containing a text value and TRUE otherwise.                    When value is a reference to an empty cell, ISNONTEXT will return TRUE.                    When value is an empty string, ISNONTEXT will return FALSE, as the empty string is considered text."
          },
          {
            "syntaxName": "ISNONTEXT returns FALSE if this is a text value or a reference to a cell containing a text value and TRUE otherwise.",
            "description": ""
          },
          {
            "syntaxName": "When value is a reference to an empty cell, ISNONTEXT will return TRUE.",
            "description": ""
          },
          {
            "syntaxName": "When value is an empty string, ISNONTEXT will return FALSE, as the empty string is considered text.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISNUMBER": {
    "header": "ISNUMBER",
    "headerDescription": "Returns TRUE if the value refers to a number.",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISNUMBER(A2)", "ISNUMBER(4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISNUMBER(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as a number.    *ISNUMBER returns TRUE if this is a number or a reference to a cell containing a numeric value and FALSE otherwise."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISODD": {
    "header": "ISODD",
    "headerDescription": "Returns TRUE if the value is odd, or FALSE if the number is even.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISODD(4)", "ISODD(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISODD(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as odd.          ISODD returns TRUE if value is an odd integer or a reference to a cell containing an odd integer, and FALSE otherwise."
          },
          {
            "syntaxName": "ISODD returns TRUE if value is an odd integer or a reference to a cell containing an odd integer, and FALSE otherwise.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISREF": {
    "header": "ISREF",
    "headerDescription": "Returns TRUE if provided value is ",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISREF(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISREF(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as a cell reference.    *ISREF returns TRUE if this is a valid cell reference, and FALSE otherwise.          Providing a string containing a valid cell reference (e.g. 'A2') for value returns FALSE as the input is a string, not a reference."
          },
          {
            "syntaxName": "Providing a string containing a valid cell reference (e.g. 'A2') for value returns FALSE as the input is a string, not a reference.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISTEXT": {
    "header": "ISTEXT",
    "headerDescription": "Returns TRUE if the cell contents refer to text.",
    "type": "Info",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ISTEXT(A2)", "ISTEXT('cat')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISTEXT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be verified as text.          ISTEXT returns TRUE if this is a text value or a reference to a cell containing a text value and FALSE otherwise."
          },
          {
            "syntaxName": "ISTEXT returns TRUE if this is a text value or a reference to a cell containing a text value and FALSE otherwise.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "NA": {
    "header": "NA",
    "headerDescription": "Returns ",
    "type": "Info",
    "parameters": [],
    "codeSyntaxUsage": ["NA()"],
    "codeSyntaxElements": [{ "codeSyntax": "NA()", "values": [] }],
    "attributes": []
  },
  "CUMIPMT": {
    "header": "CUMIPMT",
    "headerDescription": "Returns the cumulative interest paid on a loan between a start period and an end period.",
    "type": "Financial",
    "parameters": [
      "rate",
      "number_of_periods",
      "present_value",
      "first_period",
      "last_period",
      "end_or_beginning"
    ],
    "codeSyntaxUsage": [
      "CUMIPMT(0.12,12,100,1,5,0)",
      "CUMIPMT(A2,B2,C2,D2,E2,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CUMIPMT(rate, number_of_periods, present_value, first_period, last_period, end_or_beginning)",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          {
            "syntaxName": "first_period",
            "description": "The number of the payment period to begin the cumulative calculation.          first_period must be greater than or equal to 1."
          },
          {
            "syntaxName": "first_period must be greater than or equal to 1.",
            "description": ""
          },
          {
            "syntaxName": "last_period",
            "description": "The number of the payment period to end the cumulative calculation.          last_period must be greater than first_period."
          },
          {
            "syntaxName": "last_period must be greater than first_period.",
            "description": ""
          },
          {
            "syntaxName": "end_or_beginning",
            "description": "Whether payments are due at the end (0) or beginning (1) of each period."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CUMPRINC": {
    "header": "CUMPRINC",
    "headerDescription": "Returns the cumulative principal paid on a loan between a start period and an end period.",
    "type": "Financial",
    "parameters": [
      "rate",
      "number_of_periods",
      "present_value",
      "first_period",
      "last_period",
      "end_or_beginning"
    ],
    "codeSyntaxUsage": [
      "CUMPRINC(0.12,12,100,1,5,0)",
      "CUMPRINC(A2,B2,C2,D2,E2,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CUMPRINC(rate, number_of_periods, present_value, first_period, last_period, end_or_beginning)",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          {
            "syntaxName": "first_period",
            "description": "The number of the payment period to begin the cumulative calculation.          first_period must be greater than or equal to 1."
          },
          {
            "syntaxName": "first_period must be greater than or equal to 1.",
            "description": ""
          },
          {
            "syntaxName": "last_period",
            "description": "The number of the payment period to end the cumulative calculation.          last_period must be greater than first_period."
          },
          {
            "syntaxName": "last_period must be greater than first_period.",
            "description": ""
          },
          {
            "syntaxName": "end_or_beginning",
            "description": "Whether payments are due at the end (0) or beginning (1) of each period."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DB": {
    "header": "DB",
    "headerDescription": "Returns the depreciation of an asset for a period using the fixed-declining balance method.",
    "type": "Financial",
    "parameters": ["cost", "salvage", "life", "period", "[month]"],
    "codeSyntaxUsage": ["DB(100,50,10,2)", "DB(A2,A3,A4,A5,10)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DB(cost, salvage, life, period, [month])",
        "values": [
          {
            "syntaxName": "cost",
            "description": "The initial cost of the asset."
          },
          {
            "syntaxName": "salvage",
            "description": "The value of the asset at the end of depreciation."
          },
          {
            "syntaxName": "life",
            "description": "The number of periods over which the asset is depreciated."
          },
          {
            "syntaxName": "period",
            "description": "The single period within life for which to calculate depreciation."
          },
          { "syntaxName": "month", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "DDB": {
    "header": "DDB",
    "headerDescription": "Returns the depreciation of an asset for a period using the double-declining balance method.",
    "type": "Financial",
    "parameters": ["cost", "salvage", "life", "period", "[factor]"],
    "codeSyntaxUsage": ["DDB(100,50,10,2)", "DDB(A2,A3,A4,A5,2.25)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DDB(cost, salvage, life, period, [factor])",
        "values": [
          {
            "syntaxName": "cost",
            "description": "The initial cost of the asset."
          },
          {
            "syntaxName": "salvage",
            "description": "The value of the asset at the end of depreciation."
          },
          {
            "syntaxName": "life",
            "description": "The number of periods over which the asset is depreciated."
          },
          {
            "syntaxName": "period",
            "description": "The single period within life for which to calculate depreciation."
          },
          { "syntaxName": "factor", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "DOLLARDE": {
    "header": "DOLLARDE",
    "headerDescription": "Converts a price entered with a special notation to a price displayed as a decimal number.",
    "type": "Financial",
    "parameters": ["fractional_price", "unit"],
    "codeSyntaxUsage": ["DOLLARDE(100.10,32)", "DOLLARDE(A2,8)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DOLLARDE(fractional_price, unit)",
        "values": [
          {
            "syntaxName": "fractional_price",
            "description": "The price quotation given using fractional decimal conventions."
          },
          {
            "syntaxName": "unit",
            "description": "The units of the fraction; e.g. 8 for 1/8ths or 32 for 1/32nds."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DOLLARFR": {
    "header": "DOLLARFR",
    "headerDescription": "Converts a price displayed as a decimal number to a price entered with a special notation.",
    "type": "Financial",
    "parameters": ["decimal_price", "unit"],
    "codeSyntaxUsage": ["DOLLARFR(100.125,32)", "DOLLARFR(A2,8)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DOLLARFR(decimal_price, unit)",
        "values": [
          {
            "syntaxName": "decimal_price",
            "description": "The price quotation given as a decimal value."
          },
          {
            "syntaxName": "unit",
            "description": "The units of the desired fraction; e.g. 8 for 1/8ths or 32 for 1/32nds."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EFFECT": {
    "header": "EFFECT",
    "headerDescription": "Calculates the effective annual interest rate from a nominal interest rate and the number of compounding periods per year.",
    "type": "Financial",
    "parameters": ["nominal_rate", "periods_per_year"],
    "codeSyntaxUsage": ["EFFECT(0.99,12)", "EFFECT(A2,A3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EFFECT(nominal_rate, periods_per_year)",
        "values": [
          {
            "syntaxName": "nominal_rate",
            "description": "The nominal interest rate per year."
          },
          {
            "syntaxName": "periods_per_year",
            "description": "The number of compounding periods per year."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FV": {
    "header": "FV",
    "headerDescription": "Returns the future value of an investment.",
    "type": "Financial",
    "parameters": [
      "rate",
      "number_of_periods",
      "payment_amount",
      "[present_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": ["FV(2,12,100,400)", "FV(A2,B2,C2,D2,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FV(rate, number_of_periods, payment_amount, [present_value], [end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "payment_amount",
            "description": "The amount per period to be paid."
          },
          { "syntaxName": "present_value", "description": "[ OPTIONAL" },
          { "syntaxName": "end_or_beginning", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "FVSCHEDULE": {
    "header": "FVSCHEDULE",
    "headerDescription": "Returns the future value of an investment based on a rate schedule.",
    "type": "Financial",
    "parameters": ["principal", "rate_schedule"],
    "codeSyntaxUsage": [
      "FVSCHEDULE(10000,A2:A100)",
      "FVSCHEDULE(10000,{0.1,0.95,0.9,0.85})",
      "FVSCHEDULE(A2,B2:B20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FVSCHEDULE(principal, rate_schedule)",
        "values": [
          {
            "syntaxName": "principal",
            "description": "The amount of initial capital or value to compound against."
          },
          {
            "syntaxName": "rate_schedule",
            "description": "A series of interest rates to compound against the principal.          rate_schedule must be either a range or array containing the interest rates to compound, in sequence. These should be expressed either as decimals or as percentages using UNARY_PERCENT, i.e. 0.09 or UNARY_PERCENT(9) rather than 9."
          },
          {
            "syntaxName": "rate_schedule must be either a range or array containing the interest rates to compound, in sequence. These should be expressed either as decimals or as percentages using UNARY_PERCENT, i.e. 0.09 or UNARY_PERCENT(9) rather than 9.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "IPMT": {
    "header": "IPMT",
    "headerDescription": "Returns the interest portion of a given loan payment in a given payment period.",
    "type": "Financial",
    "parameters": [
      "rate",
      "period",
      "number_of_periods",
      "present_value",
      "[future_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": [
      "IPMT(0.05/12, 1, 30*12, 100000)",
      "IPMT(2,5,12,100)",
      "IPMT(A2,B2,C2,D2,E2,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IPMT(rate, period, number_of_periods, present_value, [future_value], [end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "period",
            "description": "The amortisation period, in terms of number of periods.          period must be at least 1 and at most number_of_periods."
          },
          {
            "syntaxName": "period must be at least 1 and at most number_of_periods.",
            "description": ""
          },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          { "syntaxName": "end_or_beginning", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "ISPMT": {
    "header": "ISPMT",
    "headerDescription": "Returns the interest paid for a given period of an investment with equal principal payments.",
    "type": "Financial",
    "parameters": ["rate", "period", "number_of_periods", "present_value"],
    "codeSyntaxUsage": ["ISMPT(15%, 2, 5, 1000)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ISPMT(rate, period, number_of_periods, present_value)",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate.  " },
          {
            "syntaxName": "period",
            "description": "The time frame for which you want to view the interest payment. Should be a number between 1 and number_of_periods."
          },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made.  "
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity.  "
          }
        ]
      }
    ],
    "attributes": []
  },
  "MIRR": {
    "header": "MIRR",
    "headerDescription": "Returns modified internal value for cashflows.",
    "type": "Financial",
    "parameters": [
      "cashflow_amounts",
      "financing_rate",
      "reinvestment_return_rate"
    ],
    "codeSyntaxUsage": [
      "MIRR(A2:A25,B2,B3)",
      "MIRR({-4000,200,250,300,350},0.08,0.11)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MIRR(cashflow_amounts, financing_rate, reinvestment_return_rate)",
        "values": [
          {
            "syntaxName": "cashflow_amounts",
            "description": "An array or range containing the income or payments associated with the investment.          cashflow_amounts must contain at least one negative and one positive cash flow to calculate the rate of return."
          },
          {
            "syntaxName": "cashflow_amounts must contain at least one negative and one positive cash flow to calculate the rate of return.",
            "description": ""
          },
          {
            "syntaxName": "financing_rate",
            "description": "The interest rate paid on funds invested."
          },
          {
            "syntaxName": "reinvestment_return_rate",
            "description": "The return (as a percentage) earned on reinvestment of income received from the investment."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NOMINAL": {
    "header": "NOMINAL",
    "headerDescription": "Returns the nominal interest rate.",
    "type": "Financial",
    "parameters": ["effective_rate", "periods_per_year"],
    "codeSyntaxUsage": ["NOMINAL(0.85,12)", "NOMINAL(A2,A3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NOMINAL(effective_rate, periods_per_year)",
        "values": [
          {
            "syntaxName": "effective_rate",
            "description": "The effective interest rate per year."
          },
          {
            "syntaxName": "periods_per_year",
            "description": "The number of compounding periods per year."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NPER": {
    "header": "NPER",
    "headerDescription": "Returns the number of periods for an investment assuming periodic, constant payments and a constant interest rate.",
    "type": "Financial",
    "parameters": [
      "rate",
      "payment_amount",
      "present_value",
      "[future_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": ["NPER(2,500,40000)", "NPER(A2,B2,C2,D2,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NPER(rate, payment_amount, present_value, [future_value, end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "payment_amount",
            "description": "The amount of each payment made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          { "syntaxName": "end_or_beginning", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "NPV": {
    "header": "NPV",
    "headerDescription": "Returns net present value.",
    "type": "Financial",
    "parameters": ["discount", "cashflow1", "[cashflow2, ..]"],
    "codeSyntaxUsage": ["NPV(0.08,200,250,300)", "NPV(A2,A3,A4,A5)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NPV(discount, cashflow1, [cashflow2, …])",
        "values": [
          {
            "syntaxName": "discount",
            "description": "The discount rate of the investment over one period."
          },
          {
            "syntaxName": "cashflow1",
            "description": "The first future cash flow."
          },
          { "syntaxName": "cashflow2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "PDURATION": {
    "header": "PDURATION",
    "headerDescription": "Returns number of periods to reach specific value.",
    "type": "Financial",
    "parameters": ["rate", "present_value", "future_value"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PDURATION(rate, present_value, future_value)",
        "values": [
          {
            "syntaxName": "Rate",
            "description": "Required The rate at which the investment grows each period."
          },
          {
            "syntaxName": "present_valuepresent_value",
            "description": "Required The investment's current value."
          },
          {
            "syntaxName": "future_valuefuture_value",
            "description": "Required The investment's desired future value."
          }
        ]
      }
    ],
    "attributes": []
  },
  "PMT": {
    "header": "PMT",
    "headerDescription": "Returns the periodic payment for a loan.",
    "type": "Financial",
    "parameters": [
      "rate",
      "number_of_periods",
      "present_value",
      "[future_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": [
      "PMT(0.05/12, 30*12, 100000)",
      "PMT(2,12,100)",
      "PMT(A2,B2,C2,D2,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PMT(rate, number_of_periods, present_value, [future_value, end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          { "syntaxName": "end_or_beginning", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "PPMT": {
    "header": "PPMT",
    "headerDescription": "Calculates the principal portion of a given loan payment.",
    "type": "Financial",
    "parameters": [
      "rate",
      "period",
      "number_of_periods",
      "present_value",
      "[future_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": [
      "PPMT(0.05/12, 1, 30*12, 100000)",
      "PPMT(2,5,12,100)",
      "PPMT(A2,B2,C2,D2,E2,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PPMT(rate, period, number_of_periods, present_value, [future_value, end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "period",
            "description": "The amortisation period in terms of number of periods.          period must be at least 1 and at most number_of_periods."
          },
          {
            "syntaxName": "period must be at least 1 and at most number_of_periods.",
            "description": ""
          },
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          { "syntaxName": "end_or_beginning", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "PV": {
    "header": "PV",
    "headerDescription": "Returns the present value of an investment.",
    "type": "Financial",
    "parameters": [
      "rate",
      "number_of_periods",
      "payment_amount",
      "[future_value]",
      "[end_or_beginning]"
    ],
    "codeSyntaxUsage": ["PV(2,12,100)", "PV(A2,B2,C2,D2,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PV(rate, number_of_periods, payment_amount, [future_value], [end_or_beginning])",
        "values": [
          { "syntaxName": "rate", "description": "The interest rate." },
          {
            "syntaxName": "number_of_periods - The number of payments to be made.",
            "description": ""
          },
          {
            "syntaxName": "payment_amount",
            "description": "The amount per period to be paid."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "end_or_beginning",
            "description": "[ OPTIONAL - 0 by default ] - Whether payments are due at the end (0) or beginning (1) of each period."
          }
        ]
      }
    ],
    "attributes": []
  },
  "RATE": {
    "header": "RATE",
    "headerDescription": "Returns the interest rate per period of an annuity.",
    "type": "Financial",
    "parameters": [
      "number_of_periods",
      "payment_per_period",
      "present_value",
      "[future_value]",
      "[end_or_beginning]",
      "[rate_guess]"
    ],
    "codeSyntaxUsage": [
      "RATE(12,-100,400,0,0,0.1)",
      "RATE(A2,B2,C2,D2,1,0.08)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RATE(number_of_periods, payment_per_period, present_value, [future_value, end_or_beginning, rate_guess])",
        "values": [
          {
            "syntaxName": "number_of_periods",
            "description": "The number of payments to be made."
          },
          {
            "syntaxName": "payment_per_period",
            "description": "The amount per period to be paid."
          },
          {
            "syntaxName": "present_value",
            "description": "The current value of the annuity."
          },
          { "syntaxName": "future_value", "description": "[ OPTIONAL ]" },
          {
            "syntaxName": "end_or_beginning",
            "description": "[ OPTIONAL - 0 by default ] - Whether payments are due at the end (0) or beginning (1) of each period."
          },
          { "syntaxName": "rate_guess", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "RRI": {
    "header": "RRI",
    "headerDescription": "Returns an equivalent interest rate for the growth of an investment.",
    "type": "Financial",
    "parameters": ["number_of_periods", "present_value", "future_value"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RRI(number_of_periods, present_value, future_value)",
        "values": [
          {
            "syntaxName": "number_of_periods",
            "description": "Required. The number of periods."
          },
          {
            "syntaxName": "present_value",
            "description": "Required. The present value of the investment"
          },
          {
            "syntaxName": "future_value",
            "description": "Required. The future value of the investment."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SLN": {
    "header": "SLN",
    "headerDescription": "Returns the depreciation of an asset for one period, based on a straight-line method.",
    "type": "Financial",
    "parameters": ["cost", "salvage", "life"],
    "codeSyntaxUsage": ["SLN(100,50,10)", "SLN(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SLN(cost, salvage, life)",
        "values": [
          {
            "syntaxName": "cost",
            "description": "The initial cost of the asset."
          },
          {
            "syntaxName": "salvage",
            "description": "The value of the asset at the end of depreciation."
          },
          {
            "syntaxName": "life",
            "description": "The number of periods over which the asset is depreciated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SYD": {
    "header": "SYD",
    "headerDescription": "Returns the \"sum-of-years\" depreciation for an asset in a period.",
    "type": "Financial",
    "parameters": ["cost", "salvage", "life", "period"],
    "codeSyntaxUsage": ["SYD(100,50,10,2)", "SYD(A2,A3,A4,A5)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SYD(cost, salvage, life, period)",
        "values": [
          {
            "syntaxName": "cost",
            "description": "The initial cost of the asset."
          },
          {
            "syntaxName": "salvage",
            "description": "The value of the asset at the end of depreciation."
          },
          {
            "syntaxName": "life",
            "description": "The number of periods over which the asset is depreciated."
          },
          {
            "syntaxName": "period",
            "description": "The single period within life for which to calculate depreciation."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TBILLEQ": {
    "header": "TBILLEQ",
    "headerDescription": "Returns the bond-equivalent yield for a Treasury bill.",
    "type": "Financial",
    "parameters": ["settlement", "maturity", "discount"],
    "codeSyntaxUsage": [
      "TBILLEQ(DATE(2010,1,2), DATE(2010,12,31), .09)",
      "TBILLEQ(A2,B2,C2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TBILLEQ(settlement, maturity, discount)",
        "values": [
          {
            "syntaxName": "settlement",
            "description": "The settlement date of the security, the date after issuance when the security is delivered to the buyer."
          },
          {
            "syntaxName": "maturity",
            "description": "The maturity or end date of the security, when it can be redeemed at face or par value."
          },
          {
            "syntaxName": "discount",
            "description": "The discount rate of the bill at the time of purchase."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TBILLPRICE": {
    "header": "TBILLPRICE",
    "headerDescription": "Returns the price per $100 face value for a Treasury bill.",
    "type": "Financial",
    "parameters": ["settlement", "maturity", "discount"],
    "codeSyntaxUsage": [
      "TBILLPRICE(DATE(2010,1,2), DATE(2010,12,31), .0125)",
      "TBILLPRICE(A2,B2,C2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TBILLPRICE(settlement, maturity, discount)",
        "values": [
          {
            "syntaxName": "settlement",
            "description": "The settlement date of the security, the date after issuance when the security is delivered to the buyer."
          },
          {
            "syntaxName": "maturity",
            "description": "The maturity or end date of the security, when it can be redeemed at face or par value."
          },
          {
            "syntaxName": "discount",
            "description": "The discount rate of the bill at the time of purchase."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TBILLYIELD": {
    "header": "TBILLYIELD",
    "headerDescription": "Returns the yield for a Treasury bill.",
    "type": "Financial",
    "parameters": ["settlement", "maturity", "price"],
    "codeSyntaxUsage": [
      "TBILLYIELD(DATE(2010,1,2), DATE(2010,12,31), 98.45)",
      "TBILLYIELD(A2,B2,C2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TBILLYIELD(settlement, maturity, price)",
        "values": [
          {
            "syntaxName": "settlement",
            "description": "The settlement date of the security, the date after issuance when the security is delivered to the buyer."
          },
          {
            "syntaxName": "maturity",
            "description": "The maturity or end date of the security, when it can be redeemed at face or par value."
          },
          {
            "syntaxName": "price",
            "description": "The price at which the security is bought."
          }
        ]
      }
    ],
    "attributes": []
  },
  "XNPV": {
    "header": "XNPV",
    "headerDescription": "Returns net present value.",
    "type": "Financial",
    "parameters": ["discount", "cashflow_amounts", "cashflow_dates"],
    "codeSyntaxUsage": [
      "XNPV(A2,B2:B25,C2:C25)",
      "XNPV(0.08,{200,250,300},{DATE(2012,06,23),DATE(2013,05,12),DATE(2014,02,09)})"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "XNPV(discount, cashflow_amounts, cashflow_dates)",
        "values": [
          {
            "syntaxName": "discount",
            "description": "The discount rate of the investment over one period."
          },
          {
            "syntaxName": "cashflow_amounts",
            "description": "A range of cells containing the income or payments associated with the investment."
          },
          {
            "syntaxName": "cashflow_dates",
            "description": "A range of cells with dates corresponding to the cash flows in cashflow_amounts."
          }
        ]
      }
    ],
    "attributes": []
  },
  "AND": {
    "header": "AND",
    "headerDescription": "Returns TRUE if all arguments are TRUE.",
    "type": "Logical",
    "parameters": ["logical_expression1", "[logical_expression2, ..]"],
    "codeSyntaxUsage": [
      "AND(A2 = 'foo', A3 = 'bar')",
      "AND(TRUE,FALSE,TRUE)",
      "AND(A1:A10,B1:B10)",
      "AND(0,1,2,3)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "AND(logical_expression1, [logical_expression2, ...])",
        "values": [
          {
            "syntaxName": "logical_expression1",
            "description": "An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE, or an expression that can be coerced to a logical value."
          },
          {
            "syntaxName": "logical_expression2, …",
            "description": "[ OPTIONAL ]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "FALSE": {
    "header": "FALSE",
    "headerDescription": "Returns the logical value FALSE.",
    "type": "Logical",
    "parameters": [],
    "codeSyntaxUsage": ["FALSE()"],
    "codeSyntaxElements": [{ "codeSyntax": "FALSE()", "values": [] }],
    "attributes": []
  },
  "IF": {
    "header": "IF",
    "headerDescription": "Specifies a logical test to be performed.",
    "type": "Logical",
    "parameters": ["logical_expression", "value_if_true", "value_if_false"],
    "codeSyntaxUsage": [
      "IF(A2 = 'foo','A2 is foo')",
      "IF(A2,'A2 was true','A2 was false')",
      "IF(TRUE,4,5)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IF(logical_expression, value_if_true, value_if_false)",
        "values": [
          {
            "syntaxName": "logical_expression",
            "description": "An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE."
          },
          {
            "syntaxName": "value_if_true",
            "description": "The value that the function returns if logical_expression is TRUE."
          },
          { "syntaxName": "value_if_false", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "IFNA": {
    "header": "IFNA",
    "headerDescription": "Returns the value if the cell does not contains the ",
    "type": "Logical",
    "parameters": ["value", "value_if_na"],
    "codeSyntaxUsage": ["IFNA(205, 'Na error') ", "IFNA(#N/A, 'Na error') "],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IFNA(value, value_if_na) ",
        "values": [
          {
            "syntaxName": "value",
            "description": "Required. The value to check if it is an #N/A error."
          },
          {
            "syntaxName": "value_if_na",
            "description": "Required. The value to return if the first argument is an #N/A error."
          }
        ]
      }
    ],
    "attributes": []
  },
  "IFERROR": {
    "header": "IFERROR",
    "headerDescription": "Returns the value if the cell does not contains an error value, or the alternative value if it does.",
    "type": "Logical",
    "parameters": ["value", "[value_if_error]"],
    "codeSyntaxUsage": [
      "IFERROR(A1,\"\"Error in cell A1\"\")",
      "IFERROR(A2)",
      "General usage",
      "Returns a blank if test is an error and value is null; returns the value if test is an error and value is not null; returns the test if it is not an error.",
      "",
      " ",
      "Unit price",
      "Returns the value '0' when calculating the unit price, where Quantity is null.",
      "",
      " ",
      "Student marks",
      "Returns the specified error message when searching the student Marks, where Student ID does not exist.",
      ""
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "IFERROR(value, [value_if_error])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to return if value itself is not an error."
          },
          { "syntaxName": "value_if_error", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "NOT": {
    "header": "NOT",
    "headerDescription": "Complements (inverts) a logical value.",
    "type": "Logical",
    "parameters": ["logical_expression"],
    "codeSyntaxUsage": ["NOT(A2)", "NOT(ISERR(A2))"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NOT(logical_expression)",
        "values": [
          {
            "syntaxName": "logical_expression",
            "description": "An expression or reference to a cell holding an expression that represents some logical value, i.e. TRUE or FALSE."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SWITCH": {
    "header": "SWITCH",
    "headerDescription": "Evaluates a list of arguments, consisting of an expression followed by a value.",
    "type": "Logical",
    "parameters": [
      "expression",
      "case1",
      "value1",
      "[default or case2, value2]",
      "…"
    ],
    "codeSyntaxUsage": [
      "SWITCH(A1:A10, 0, “No”, 1, “Other”)",
      "SWITCH(A3:A8, 4, “Four”, 8, “Eight”)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SWITCH(expression, case1, value1, [case2, value2, ...], [default])",
        "values": [
          { "syntaxName": "expression", "description": "Any valid values." },
          {
            "syntaxName": "case1",
            "description": "The first case to be checked against expression."
          },
          {
            "syntaxName": "value1",
            "description": "The corresponding value to be returned if case1 matches expression."
          },
          {
            "syntaxName": "case2, value2, …",
            "description": "Optional: Additional cases and values if the first one doesn’t match the expression."
          },
          {
            "syntaxName": "default",
            "description": "Optional: An optional value, specified as the last parameter, to be returned if none of the cases matches the expression."
          }
        ]
      }
    ],
    "attributes": []
  },
  "OR": {
    "header": "OR",
    "headerDescription": "Returns TRUE if at least one argument is TRUE.",
    "type": "Logical",
    "parameters": ["logical_expression1", "[logical_expression2, ..]"],
    "codeSyntaxUsage": [
      "OR(A2 = 'foo', A3 = 'bar')",
      "OR(TRUE,FALSE,TRUE)",
      "OR(A1:A10,B1:B10)",
      "OR(0,1,2,3)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "OR(logical_expression1, [logical_expression2, ...])",
        "values": [
          {
            "syntaxName": "logical_expression1",
            "description": "An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE, or an expression that can be coerced to a logical value."
          },
          {
            "syntaxName": "logical_expression2, …",
            "description": "[ OPTIONAL ]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "TRUE": {
    "header": "TRUE",
    "headerDescription": "The logical value is set to TRUE.",
    "type": "Logical",
    "parameters": [],
    "codeSyntaxUsage": ["TRUE()"],
    "codeSyntaxElements": [{ "codeSyntax": "TRUE()", "values": [] }],
    "attributes": []
  },
  "XOR": {
    "header": "XOR",
    "headerDescription": "Returns true if an odd number of arguments evaluates to TRUE.",
    "type": "Logical",
    "parameters": ["logical_expression1", "[logical_expression2, ..]"],
    "codeSyntaxUsage": [
      "XOR(TRUE, FALSE, TRUE)",
      "XOR(A2=TRUE, A3=FALSE)",
      "A10, B1",
      "XOR(0, 1, 2, 3)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "XOR(logical_expression1, [logical_expression2, …])",
        "values": [
          {
            "syntaxName": "logical_expression1",
            "description": "An expression or reference to a cell containing an expression that represents some logical value; e.g. 'TRUE' or 'FALSE,' or an expression that can be coerced to a logical value.  "
          },
          {
            "syntaxName": "logical_expression2",
            "description": "More expressions or cell references that represent logical values. A second logical expression, and any additional expressions are optional."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHOOSE": {
    "header": "CHOOSE",
    "headerDescription": "Uses an index to return a value from a list of up to 30 values.",
    "type": "Lookup",
    "parameters": ["index", "choice1", "[choice2, ..]"],
    "codeSyntaxUsage": ["CHOOSE(2,'A','B','C')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHOOSE(index, choice1, [choice2, ...])",
        "values": [
          {
            "syntaxName": "index",
            "description": "Which choice (of the up to 29 provided) to be returned.          If index is zero, negative or greater than the number of choices provided, the #NUM! error is returned."
          },
          {
            "syntaxName": "If index is zero, negative or greater than the number of choices provided, the #NUM! error is returned.",
            "description": ""
          },
          {
            "syntaxName": "choice1",
            "description": "A potential value to be returned. Required. May be a reference to a cell or an individual value."
          },
          {
            "syntaxName": "choice2, ...",
            "description": "Additional values among which to choose."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COLUMN": {
    "header": "COLUMN",
    "headerDescription": "Returns column number of a given reference or formula reference if argument not provided.",
    "type": "Lookup",
    "parameters": ["[cell_reference]"],
    "codeSyntaxUsage": ["COLUMN(A9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COLUMN([cell_reference])",
        "values": [
          { "syntaxName": "cell_reference", "description": "[ OPTIONAL" },
          {
            "syntaxName": "if cell_reference is a range more than one cell wide and the formula is not used as an array formula, the position of the first column in cell_reference is returned.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "COLUMNS": {
    "header": "COLUMNS",
    "headerDescription": "Returns the number of columns in the given reference.",
    "type": "Lookup",
    "parameters": ["range"],
    "codeSyntaxUsage": ["COLUMNS(A9:W62)", "COLUMNS({1,2,3,4,5})"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COLUMNS(range)",
        "values": [
          {
            "syntaxName": "range",
            "description": "The range whose column count will be returned"
          }
        ]
      }
    ],
    "attributes": []
  },
  "FORMULATEXT": {
    "header": "FORMULATEXT",
    "headerDescription": "Returns a formula in a given cell as a string.",
    "type": "Lookup",
    "parameters": ["cell"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FORMULATEXT(cell) ",
        "values": [
          {
            "syntaxName": "mobile",
            "description": "The cell to be verified as containing a formula. "
          }
        ]
      }
    ],
    "attributes": []
  },
  "HLOOKUP": {
    "header": "HLOOKUP",
    "headerDescription": "Searches horizontally with reference to adjacent cells to the bottom.",
    "type": "Lookup",
    "parameters": ["search_key", "range", "index", "[is_sorted]"],
    "codeSyntaxUsage": ["HLOOKUP(10003, A2:Z6, 2, FALSE)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HLOOKUP(search_key, range, index, [is_sorted])",
        "values": [
          {
            "syntaxName": "search_key",
            "description": "The value to search for. For example, 42, 'Cats' or I24."
          },
          {
            "syntaxName": "range",
            "description": "The range to be considered for the search. The first row in the range is searched for the key specified in search_key."
          },
          {
            "syntaxName": "index",
            "description": "The row index of the value to be returned, where the first row in range is numbered 1.          If index is not between 1 and the number of rows in range, #VALUE! is returned."
          },
          {
            "syntaxName": "If index is not between 1 and the number of rows in range, #VALUE! is returned.",
            "description": ""
          },
          { "syntaxName": "is_sorted", "description": "[OPTIONAL" },
          {
            "syntaxName": "If is_sorted is TRUE or omitted, the nearest match (less than or equal to the search key) is returned. If all values in the search row are greater than the search key, #N/A is returned.",
            "description": ""
          },
          {
            "syntaxName": "If is_sorted is set to TRUE or omitted, and the first row of the range is not in sorted order, an incorrect value might be returned.",
            "description": ""
          },
          {
            "syntaxName": "If is_sorted is FALSE, only an exact match is returned. If there are multiple matching values, the content of the cell corresponding to the first value found is returned, and #N/A is returned if no such value is found.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "INDEX": {
    "header": "INDEX",
    "headerDescription": "Returns the content of a cell, specified by row and column number, or an optional range name.",
    "type": "Lookup",
    "parameters": ["reference", "[row]", "[column]"],
    "codeSyntaxUsage": ["INDEX(A1:C20, 5, 1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "INDEX(reference, [row], [column])",
        "values": [
          {
            "syntaxName": "reference - The range of cells from which the values are returned.",
            "description": ""
          },
          {
            "syntaxName": "row - [OPTIONAL - 0 by default] - The index of the row to be returned from within the reference range of cells.",
            "description": ""
          },
          {
            "syntaxName": "column - [OPTIONAL - 0 by default] - The index of the column to be returned from within the reference range of cells.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "MATCH": {
    "header": "MATCH",
    "headerDescription": "Returns the relative position of an item in an array that matches a specified value.",
    "type": "Lookup",
    "parameters": ["search_key", "range", "[search_type]"],
    "codeSyntaxUsage": [
      "MATCH('Sunday',A2:A9,0)",
      "MATCH(DATE(2012,1,1),A2:F2)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MATCH(search_key, range, [search_type])",
        "values": [
          {
            "syntaxName": "search_key",
            "description": "The value to search for. For example, 42, 'Cats' or I24."
          },
          {
            "syntaxName": "range",
            "description": "The one-dimensional array to be searched.          If a range with both height and width greater than 1 is used, MATCH will return #N/A!."
          },
          {
            "syntaxName": "If a range with both height and width greater than 1 is used, MATCH will return #N/A!.",
            "description": ""
          },
          { "syntaxName": "search_type", "description": "[ OPTIONAL" },
          {
            "syntaxName": "1, the default, causes MATCH to assume that the range is sorted in ascending order and return the largest value less than or equal to search_key.",
            "description": ""
          },
          {
            "syntaxName": "0 indicates exact match and is required in situations where range is not sorted.",
            "description": ""
          },
          {
            "syntaxName": "-1 causes MATCH to assume that the range is sorted in descending order and return the smallest value greater than or equal to search_key.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "OFFSET": {
    "header": "OFFSET",
    "headerDescription": "Returns the value of a cell offset by a certain number of rows and columns from a given reference point.",
    "type": "Lookup",
    "parameters": [
      "cell_reference",
      "offset_rows",
      "offset_columns",
      "[height]",
      "[width]"
    ],
    "codeSyntaxUsage": ["OFFSET(A2,3,4,2,2)", "OFFSET(A2,1,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "OFFSET(cell_reference, offset_rows, offset_columns, [height], [width])",
        "values": [
          {
            "syntaxName": "cell_reference",
            "description": "The starting point from which to count the offset rows and columns."
          },
          {
            "syntaxName": "offset_rows",
            "description": "The number of rows to shift by.          offset_rows must be an integer but may be negative. If a decimal value is provided, the decimal part will be truncated."
          },
          {
            "syntaxName": "offset_rows must be an integer but may be negative. If a decimal value is provided, the decimal part will be truncated.",
            "description": ""
          },
          {
            "syntaxName": "offset_columns",
            "description": "The number of columns to shift by.          offset_columns must be an integer but may be negative. If a decimal value is provided, the decimal part will be truncated."
          },
          {
            "syntaxName": "offset_columns must be an integer but may be negative. If a decimal value is provided, the decimal part will be truncated.",
            "description": ""
          },
          { "syntaxName": "height", "description": "[ OPTIONAL ]" },
          { "syntaxName": "width", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "ROW": {
    "header": "ROW",
    "headerDescription": "Returns row number of a given reference or formula reference if argument not provided.",
    "type": "Lookup",
    "parameters": ["[cell_reference]"],
    "codeSyntaxUsage": ["ROW(A9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROW([cell_reference])",
        "values": [
          { "syntaxName": "cell_reference", "description": "[ OPTIONAL" },
          {
            "syntaxName": "if cell_reference is a range more than one cell wide and the formula is not used as an array formula, only the numeric value of the first row in cell_reference is returned.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ROWS": {
    "header": "ROWS",
    "headerDescription": "Returns the number of rows in the given reference.",
    "type": "Lookup",
    "parameters": ["range"],
    "codeSyntaxUsage": ["ROWS(A9:A62)", "ROWS({1;2;3;4;5})"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROWS(range)",
        "values": [
          {
            "syntaxName": "range",
            "description": "The range whose row count will be returned"
          }
        ]
      }
    ],
    "attributes": []
  },
  "VLOOKUP": {
    "header": "VLOOKUP",
    "headerDescription": "Searches vertically with reference to adjacent cells to the right.",
    "type": "Lookup",
    "parameters": ["search_key", "range", "index", "[is_sorted]"],
    "codeSyntaxUsage": ["VLOOKUP(10003, A2:B26, 2, FALSE)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "VLOOKUP(search_key, range, index, [is_sorted])",
        "values": [
          {
            "syntaxName": "search_key",
            "description": "The value to search for. For example, 42, 'Cats' or I24."
          },
          {
            "syntaxName": "range",
            "description": "The range to consider for the search. The first column in the range is searched for the key specified in search_key."
          },
          {
            "syntaxName": "index",
            "description": "The column index of the value to be returned, where the first column in range is numbered 1.          If index is not between 1 and the number of columns in range, #VALUE! is returned."
          },
          {
            "syntaxName": "If index is not between 1 and the number of columns in range, #VALUE! is returned.",
            "description": ""
          },
          { "syntaxName": "is_sorted", "description": "[TRUE by default]" },
          {
            "syntaxName": "It’s recommended to set is_sorted to FALSE. If set to FALSE, an exact match is returned. If there are multiple matching values, the content of the cell corresponding to the first value found is returned, and #N/A is returned if no such value is found.",
            "description": ""
          },
          {
            "syntaxName": "If is_sorted is TRUE or omitted, the nearest match (less than or equal to the search key) is returned. If all values in the search column are greater than the search key, #N/A is returned.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ABS": {
    "header": "ABS",
    "headerDescription": "Returns the absolute value of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ABS(-2)", "ABS(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ABS(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number of which to return the absolute value."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ACOS": {
    "header": "ACOS",
    "headerDescription": "Returns the inverse trigonometric cosine of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ACOS(0)", "ACOS(A2)", "ACOS(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ACOS(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse cosine is calculated. Must be between -1 and 1, inclusive."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ACOSH": {
    "header": "ACOSH",
    "headerDescription": "Returns the inverse hyperbolic cosine of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ACOSH(2)", "ACOSH(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ACOSH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse hyperbolic cosine is calculated. Must be greater than or equal to 1."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ACOT": {
    "header": "ACOT",
    "headerDescription": "Returns the inverse trigonometric cotangent of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ACOT(0)", "ACOT(-1)", "ACOT(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ACOT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse cotangent is calculated.               Values must be a number.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "ACOTH": {
    "header": "ACOTH",
    "headerDescription": "Returns the inverse hyperbolic cotangent of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ACOTH(2)", "ACOTH(10)", "ACOTH(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ACOTH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse hyperbolic cotangent is calculated.               Values must not be a number between -1 and 1.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "ARABIC": {
    "header": "ARABIC",
    "headerDescription": "Converts number from roman form.",
    "type": "Text",
    "parameters": ["roman_numeral"],
    "codeSyntaxUsage": ["ARABIC(\"\"XIV\"\")", "ARABIC(\"\"MMXIII\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ARABIC(roman_numeral)",
        "values": [
          {
            "syntaxName": "roman_numeral",
            "description": "The Roman numeral to be formatted, whose value must be between 1 and 3,999, inclusive."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ASIN": {
    "header": "ASIN",
    "headerDescription": "Returns the inverse trigonometric sine of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ASIN(0)", "ASIN(A2)", "ASIN(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ASIN(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse sine is calculated. Must be between -1 and 1, inclusive."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ASINH": {
    "header": "ASINH",
    "headerDescription": "Returns the inverse hyperbolic sine of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ASINH(0.9)", "ASINH(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ASINH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse hyperbolic sine is calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ATAN": {
    "header": "ATAN",
    "headerDescription": "Returns the inverse trigonometric tangent of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ATAN(0)", "ATAN(A2)", "ATAN(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ATAN(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the inverse tangent is calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ATAN2": {
    "header": "ATAN2",
    "headerDescription": "Returns the inverse trigonometric tangent of the specified x and y coordinates.",
    "type": "Math",
    "parameters": ["x", "y"],
    "codeSyntaxUsage": ["ATAN2(4,3)", "ATAN2(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ATAN2(x,y)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The x coordinate of the endpoint of the line segment for which the angle is calculated from the x-axis."
          },
          {
            "syntaxName": "y - The y coordinate of the endpoint of the line segment for which the angle is calculated from the x-axis.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ATANH": {
    "header": "ATANH",
    "headerDescription": "Returns the inverse hyperbolic tangent of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ATANH(0.9)", "ATANH(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ATANH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which to calculate the inverse hyperbolic tangent. Must be between -1 and 1, exclusive."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BASE": {
    "header": "BASE",
    "headerDescription": "Converts a positive integer to a specified base into a text from the numbering system.",
    "type": "Math",
    "parameters": ["value", "base", "[min_length]"],
    "codeSyntaxUsage": ["BASE(255, 16)", "BASE(A2, 2)", "BASE(4095, 16, 6)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BASE(value, base, [min_length])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number to convert into base.               The value should be an integer greater than or equal to zero.            "
          },
          {
            "syntaxName": "base",
            "description": "The base (or radix) to convert the value number into.               The base should be an integer from 2 to 36.            "
          },
          {
            "syntaxName": "min_length",
            "description": "(Optional) The minimum length of the text returned.                         If the minimum length value is greater than the number of significant digits in the result, the result is left-padded with zeros until the total number of digits reaches significant_digits.                    "
          }
        ]
      }
    ],
    "attributes": []
  },
  "CEILING": {
    "header": "CEILING",
    "headerDescription": "Rounds a number up to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["value", "[factor]"],
    "codeSyntaxUsage": ["CEILING(23.25,0.1)", "CEILING(A2,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CEILING(value, [factor])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to round up to the nearest integer multiple of factor."
          },
          { "syntaxName": "factor", "description": "[OPTIONAL: 1 by default]" },
          { "syntaxName": "factor may not be equal to 0.", "description": "" }
        ]
      }
    ],
    "attributes": []
  },
  "CEILING.MATH": {
    "header": "CEILING.MATH",
    "headerDescription": "Rounds a number up to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["number", "[significance]", "[mode]"],
    "codeSyntaxUsage": [
      "CEILING.MATH(5.4)  CEILING.MATH(32, 5)  CEILING.MATH(-26.2, 10, 1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CEILING.MATH(number, [significance], [mode])",
        "values": [
          {
            "syntaxName": "number",
            "description": "The value to be rounded up to the nearest integer or, if specified, the nearest multiple of significance.  "
          },
          {
            "syntaxName": "significance",
            "description": "The value to whose multiple number will be rounded. [OPTIONAL: 1 by default]"
          },
          {
            "syntaxName": "mode",
            "description": "If number is negative, specifies the rounding direction. If 0 or blank, it's rounded up towards zero. Otherwise, it's rounded down away from zero. [OPTIONAL]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "CEILING.PRECISE": {
    "header": "CEILING.PRECISE",
    "headerDescription": "Rounds a number up to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["number", "[significance]"],
    "codeSyntaxUsage": [
      "CEILING.PRECISE(-10.5, 1)  CEILING.PRECISE(96, 10)  CEILING.PRECISE(-23.25, 0.1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CEILING.PRECISE(number, [significance])",
        "values": [
          {
            "syntaxName": "number",
            "description": "The value to be rounded up to the nearest integer or multiple of significance.  "
          },
          {
            "syntaxName": "significance",
            "description": "The number to whose multiples number will be rounded. The sign of significance will be ignored.  [OPTIONAL: 1 by default]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "COMBIN": {
    "header": "COMBIN",
    "headerDescription": "Returns number of combinations (without repetitions).",
    "type": "Math",
    "parameters": ["n", "k"],
    "codeSyntaxUsage": ["COMBIN(4,2)", "COMBIN(A2,B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COMBIN(n, k)",
        "values": [
          {
            "syntaxName": "n",
            "description": "The size of the pool of objects to choose from."
          },
          {
            "syntaxName": "k",
            "description": "The number of objects to choose."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COMBINA": {
    "header": "COMBINA",
    "headerDescription": "Returns number of combinations (with repetitions).",
    "type": "Math",
    "parameters": ["n", "k"],
    "codeSyntaxUsage": ["COMBINA(5, 3)", "COMBINA(A1, B1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COMBINA(n, k)",
        "values": [
          {
            "syntaxName": "n",
            "description": "The size pool of objects to choose from.               Given n values should be greater than or equal to 0.            "
          },
          {
            "syntaxName": "k",
            "description": "The number of objects to choose.               Given k values should be greater than or equal to 0.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "COS": {
    "header": "COS",
    "headerDescription": "Returns the cosine of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["COS(PI())", "COS(A2)", "COS(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COS(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle to find the cosine of, in radians."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COSH": {
    "header": "COSH",
    "headerDescription": "Returns the hyperbolic cosine of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["COSH(A2)", "COSH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COSH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value to calculate the hyperbolic cosine of."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COT": {
    "header": "COT",
    "headerDescription": "Returns the cotangent of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["COT(3.14)", "COT(A1)", "COT(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COT(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle for which the cotangent is to be found, in radians.  "
          }
        ]
      }
    ],
    "attributes": []
  },
  "COTH": {
    "header": "COTH",
    "headerDescription": "Returns the hyperbolic cotangent of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["COTH(A1)", "COTH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COTH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value for which to calculate the hyperbolic cotangent."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COUNTUNIQUE": {
    "header": "COUNTUNIQUE",
    "headerDescription": "Counts the number of unique values in a list of specified values and ranges.",
    "type": "Math",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "COUNTUNIQUE(A1:C100)",
      "COUNTUNIQUE(1,1,2,3,5,8,13,A2,B6:B9)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNTUNIQUE(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider for uniqueness."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "CSC": {
    "header": "CSC",
    "headerDescription": "Returns the cosecans of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["CSC(PI())", "CSC(A1)", "CSC(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CSC(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "Any real value for which the hyperbolic cosecant is calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CSCH": {
    "header": "CSCH",
    "headerDescription": "Returns the hyperbolic cosecans of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["CSCH(A1)", "CSCH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CSCH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value for which the hyperbolic cosecant is calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DECIMAL": {
    "header": "DECIMAL",
    "headerDescription": "Converts text with characters from a number system to a positive integer in the base radix given.",
    "type": "Math",
    "parameters": ["value", "base"],
    "codeSyntaxUsage": ["DECIMAL(101,2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DECIMAL(value, base)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The unsigned value to be converted to decimal, provided as a string.  "
          },
          {
            "syntaxName": "base",
            "description": "The base (or radix) to convert the number into. The base is an integer from 2 to 36."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DEGREES": {
    "header": "DEGREES",
    "headerDescription": "Converts radians into degrees.",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["DEGREES(PI())", "DEGREES(6)", "DEGREES(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DEGREES(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle to be converted from radians to degrees."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EVEN": {
    "header": "EVEN",
    "headerDescription": "Rounds a positive number up to the next even integer and a negative number down to the next even integer.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["EVEN(3)", "EVEN(-0.6)", "EVEN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EVEN(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be rounded to the next greatest even number.          If value is negative, it will be rounded down to the next negative even number with greater absolute value."
          },
          {
            "syntaxName": "If value is negative, it will be rounded down to the next negative even number with greater absolute value.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "EXP": {
    "header": "EXP",
    "headerDescription": "Returns constant e raised to the power of a number.",
    "type": "Math",
    "parameters": ["exponent"],
    "codeSyntaxUsage": ["EXP(2)", "EXP(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EXP(exponent)",
        "values": [
          {
            "syntaxName": "exponent",
            "description": "The exponent to raise e to."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FACT": {
    "header": "FACT",
    "headerDescription": "Returns a factorial of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["FACT(3)", "FACT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FACT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number or reference to a number whose factorial will be calculated and returned."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FACTDOUBLE": {
    "header": "FACTDOUBLE",
    "headerDescription": "Returns a double factorial of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["FACTDOUBLE(6)", "FACTDOUBLE(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FACTDOUBLE(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number, or reference to a number, whose double factorial will be calculated and returned."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FLOOR": {
    "header": "FLOOR",
    "headerDescription": "Rounds a number down to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["value", "[factor]"],
    "codeSyntaxUsage": ["FLOOR(23.25,0.1)", "FLOOR(A2,1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FLOOR(value, [factor])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to round down to the nearest integer multiple of factor."
          },
          { "syntaxName": "factor", "description": "[OPTIONAL" },
          { "syntaxName": "factor may not be equal to 0.", "description": "" }
        ]
      }
    ],
    "attributes": []
  },
  "FLOOR.MATH": {
    "header": "FLOOR.MATH",
    "headerDescription": "Rounds a number down to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["number", "[significance]", "[mode]"],
    "codeSyntaxUsage": [
      "FLOOR.MATH(5.4)  FLOOR.MATH(A2)  FLOOR.MATH(32, 5)  FLOOR.MATH(-26.2, 10, 1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FLOOR.MATH(number, [significance], [mode])",
        "values": [
          {
            "syntaxName": "number",
            "description": "The value to round down to the nearest integer or, if specified, the nearest multiple of significance.  "
          },
          {
            "syntaxName": "significance",
            "description": "The number to which multiples number will be rounded. The sign of significance will be ignored. It's 1 by default. [OPTIONAL]"
          },
          {
            "syntaxName": "mode",
            "description": "If number is negative, specifies the rounding direction. If 0 or blank, it's rounded away from zero. Otherwise, it's rounded towards zero. [OPTIONAL]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "FLOOR.PRECISE": {
    "header": "FLOOR.PRECISE",
    "headerDescription": "Rounds a number down to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["number", "[significance]"],
    "codeSyntaxUsage": [
      "FLOOR.PRECISE(-10.5, 1)",
      "FLOOR.PRECISE(96, 10)",
      "FLOOR.PRECISE(-23.25,0.1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FLOOR.PRECISE(number, [significance])",
        "values": [
          {
            "syntaxName": "number",
            "description": "The value to round down to the nearest integer or multiple of significance.  "
          },
          {
            "syntaxName": "significance",
            "description": "The number to which the multiple's number will be rounded.               Optional (defaults to 1).        The sign of this value is ignored.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "GCD": {
    "header": "GCD",
    "headerDescription": "Computes greatest common divisor of numbers.",
    "type": "Math",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["GCD(A2:A5)", "GCD(24,96,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GCD(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range whose factors are considered in a calculation to find the greatest common divisor."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "INT": {
    "header": "INT",
    "headerDescription": "Rounds a number down to the nearest integer.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["INT(99.44)", "INT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "INT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be rounded down to the nearest integer."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ISO.CEILING": {
    "header": "ISO.CEILING",
    "headerDescription": "Rounds a number up to the nearest multiple of Significance.",
    "type": "Math",
    "parameters": ["number", "[significance]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "LCM": {
    "header": "LCM",
    "headerDescription": "Computes least common multiplicity of numbers.",
    "type": "Math",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["LCM(A2:A5)", "LCM(2,3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LCM(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range whose factors are considered in a calculation to find the least common multiple."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "LN": {
    "header": "LN",
    "headerDescription": "Returns the natural logarithm based on the constant e of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["LN", "LN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LN(value)",
        "values": [
          {
            "syntaxName": "value - The value for which to calculate the logarithm, base e.          value must be positive.",
            "description": ""
          },
          { "syntaxName": "value must be positive.", "description": "" }
        ]
      }
    ],
    "attributes": []
  },
  "LOG": {
    "header": "LOG",
    "headerDescription": "Returns the logarithm of a number to the specified base.",
    "type": "Math",
    "parameters": ["value", "base"],
    "codeSyntaxUsage": ["LOG(128,2)", "LOG(A2,3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LOG(value, [base])",
        "values": [
          {
            "syntaxName": "value - the value for which to calculate the logarithm given base.          value must be positive.",
            "description": ""
          },
          { "syntaxName": "value must be positive.", "description": "" },
          {
            "syntaxName": "base - [10 by default] the base to use for calculation of the logarithm.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "LOG10": {
    "header": "LOG10",
    "headerDescription": "Returns the base-10 logarithm of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["LOG10(100)", "LOG10(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LOG10(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which the logarithm is calculated, base 10.          value must be positive."
          },
          { "syntaxName": "value must be positive.", "description": "" }
        ]
      }
    ],
    "attributes": []
  },
  "MOD": {
    "header": "MOD",
    "headerDescription": "Returns the remainder when one integer is divided by another.",
    "type": "Math",
    "parameters": ["dividend", "divisor"],
    "codeSyntaxUsage": ["MOD(10,4)", "MOD(A2,B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MOD(dividend, divisor)",
        "values": [
          {
            "syntaxName": "dividend",
            "description": "The number to be divided to find the remainder."
          },
          { "syntaxName": "divisor", "description": "The number to divide by." }
        ]
      }
    ],
    "attributes": []
  },
  "MROUND": {
    "header": "MROUND",
    "headerDescription": "Rounds number to the neares multiplicity.",
    "type": "Math",
    "parameters": ["value", "factor"],
    "codeSyntaxUsage": ["MROUND(21,14)", "MROUND(A2,3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MROUND(value,factor)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number to be rounded to the nearest integer multiple of another."
          },
          {
            "syntaxName": "factor",
            "description": "The number whose multiples value will be rounded to."
          }
        ]
      }
    ],
    "attributes": []
  },
  "MULTINOMIAL": {
    "header": "MULTINOMIAL",
    "headerDescription": "Returns number of multiset combinations.",
    "type": "Math",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["MULTINOMIAL(1,2,3)", "MULTINOMIAL(A2:A9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MULTINOMIAL(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to consider."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ODD": {
    "header": "ODD",
    "headerDescription": "Rounds a positive number up to the nearest odd integer and a negative number down to the nearest odd integer.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["ODD(2)", "ODD(-0.6)", "ODD(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ODD(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to round to the next greatest odd number.          If value is negative, it will be rounded down to the next negative odd number with greater absolute value."
          },
          {
            "syntaxName": "If value is negative, it will be rounded down to the next negative odd number with greater absolute value.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "PI": {
    "header": "PI",
    "headerDescription": "Returns 3.14159265358979, the value of the mathematical constant PI to 14 decimal places.",
    "type": "Math",
    "parameters": [],
    "codeSyntaxUsage": ["PI()"],
    "codeSyntaxElements": [{ "codeSyntax": "PI()", "values": [] }],
    "attributes": []
  },
  "POWER": {
    "header": "POWER",
    "headerDescription": "Returns a number raised to another number.",
    "type": "Math",
    "parameters": ["base", "exponent"],
    "codeSyntaxUsage": ["POWER(4,0.5)", "POWER(A2,B2)", "POWER(2,5)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "POWER(base, exponent)",
        "values": [
          {
            "syntaxName": "base - The number to raise to the exponent power.          If base is negative, exponent must be an integer.",
            "description": ""
          },
          {
            "syntaxName": "If base is negative, exponent must be an integer.",
            "description": ""
          },
          {
            "syntaxName": "exponent - The exponent to raise base to.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "PRODUCT": {
    "header": "PRODUCT",
    "headerDescription": "Returns product of numbers.",
    "type": "Math",
    "parameters": ["factor1", "[factor2, ..]"],
    "codeSyntaxUsage": ["PRODUCT(A2:A100)", "PRODUCT(1,2,3,4,5,A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PRODUCT(factor1, [factor2, ...])",
        "values": [
          {
            "syntaxName": "factor1",
            "description": "The first number or range to calculate for the product."
          },
          {
            "syntaxName": "factor2 ... factor 30",
            "description": "[ OPTIONAL ]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "QUOTIENT": {
    "header": "QUOTIENT",
    "headerDescription": "Returns integer part of a division.",
    "type": "Math",
    "parameters": ["dividend", "divisor"],
    "codeSyntaxUsage": ["QUOTIENT(4,2)", "QUOTIENT(A2,B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "QUOTIENT(dividend, divisor)",
        "values": [
          {
            "syntaxName": "dividend",
            "description": "The number to be divided."
          },
          {
            "syntaxName": "divisor",
            "description": "The number to be divided by (cannot equal 0)."
          }
        ]
      }
    ],
    "attributes": []
  },
  "RADIANS": {
    "header": "RADIANS",
    "headerDescription": "Converts degrees to radians.",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["RADIANS(180)", "RADIANS(6)", "RADIANS(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RADIANS(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle to be converted from degrees to radians."
          }
        ]
      }
    ],
    "attributes": []
  },
  "RAND": {
    "header": "RAND",
    "headerDescription": "Returns a random number between 0 and 1.",
    "type": "Math",
    "parameters": [],
    "codeSyntaxUsage": ["RAND()"],
    "codeSyntaxElements": [{ "codeSyntax": "RAND()", "values": [] }],
    "attributes": []
  },
  "RANDBETWEEN": {
    "header": "RANDBETWEEN",
    "headerDescription": "Returns a random integer between two numbers.",
    "type": "Math",
    "parameters": ["low", "high"],
    "codeSyntaxUsage": ["RANDBETWEEN(1,10)", "RANDBETWEEN(A2,A3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RANDBETWEEN(low, high)",
        "values": [
          {
            "syntaxName": "low",
            "description": "The low end of the random range."
          },
          {
            "syntaxName": "high",
            "description": "The high end of the random range."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ROMAN": {
    "header": "ROMAN",
    "headerDescription": "Converts number to roman form.",
    "type": "Text",
    "parameters": ["number", "[rule_relaxation]"],
    "codeSyntaxUsage": ["ROMAN(499,0)", "ROMAN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROMAN(number, [rule_relaxation])",
        "values": [
          {
            "syntaxName": "number",
            "description": "The number to be formatted, between 1 and 3999, inclusive."
          },
          { "syntaxName": "rule_relaxation", "description": "[ OPTIONAL" },
          {
            "syntaxName": "0 indicates strict precedence rules, where I may only precede V and X, V may only precede X, X may only precede L and C, L may only precede C and C may only precede D and M. Therefore, ROMAN(499,0) is CDXCIX.",
            "description": ""
          },
          {
            "syntaxName": "1 indicates a relaxation where V may precede L and C and L may precede D and M. Therefore, ROMAN(499,1) is LDVLIV.",
            "description": ""
          },
          {
            "syntaxName": "2 indicates a further relaxation where I may precede L and C, and X may precede D and M. Therefore, ROMAN(499,2) is XDIX.",
            "description": ""
          },
          {
            "syntaxName": "3 indicates a further relaxation where V may precede D and M. Therefore, ROMAN(499,3) is VDIV.",
            "description": ""
          },
          {
            "syntaxName": "4 indicates a further relaxation where I may precede D and M. Therefore, ROMAN(499,4) is ID.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ROUND": {
    "header": "ROUND",
    "headerDescription": "Rounds a number to a certain number of decimal places.",
    "type": "Math",
    "parameters": ["value", "[places]"],
    "codeSyntaxUsage": ["ROUND(99.44,1)", "ROUND(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROUND(value, [places])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be rounded to places number of places."
          },
          { "syntaxName": "places", "description": "[ OPTIONAL" },
          {
            "syntaxName": "places may be negative, in which case value is rounded at the specified number of digits to the left of the decimal point.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ROUNDDOWN": {
    "header": "ROUNDDOWN",
    "headerDescription": "Rounds a number down, toward zero, to a certain precision.",
    "type": "Math",
    "parameters": ["value", "[places]"],
    "codeSyntaxUsage": ["ROUNDDOWN(99.44,1)", "ROUNDDOWN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROUNDDOWN(value,[places])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be rounded to places number of places, always rounding down."
          },
          { "syntaxName": "places", "description": "[ OPTIONAL" },
          {
            "syntaxName": "places may be negative, in which case value is rounded at the specified number of digits to the left of the decimal point.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "ROUNDUP": {
    "header": "ROUNDUP",
    "headerDescription": "Rounds a number up, away from zero, to a certain precision.",
    "type": "Math",
    "parameters": ["value", "[places]"],
    "codeSyntaxUsage": ["ROUNDUP(99.44,1)", "ROUNDUP(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "ROUNDUP(value,[places])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to round to places number of places, always rounding up."
          },
          { "syntaxName": "places", "description": "[ OPTIONAL" },
          {
            "syntaxName": "places may be negative, in which case value is rounded at the specified number of digits to the left of the decimal point.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "SEC": {
    "header": "SEC",
    "headerDescription": "Returns the secans of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["SEC(3.14)", "SEC(A1)", "=SEC(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SEC(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle of which to find the secant, measured in radians."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SECH": {
    "header": "SECH",
    "headerDescription": "Returns the hyperbolic secans of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["SECH(A1)", "SECH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SECH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value for which to calculate the hyperbolic secant."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SERIESSUM": {
    "header": "SERIESSUM",
    "headerDescription": "Evaluates series at a point.",
    "type": "Math",
    "parameters": ["x", "n", "m", "a"],
    "codeSyntaxUsage": [
      "SERIESSUM(1,0,1,{FACT(0),FACT(1),FACT(2),FACT(3),FACT(4)})",
      "SERIESSUM(A2,0,2,B2:B10)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SERIESSUM(x, n, m, a)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the power series. Varies depending on the type of approximation; may be angle, exponent or some other value."
          },
          {
            "syntaxName": "n",
            "description": "The initial power to which x is raised in the power series."
          },
          {
            "syntaxName": "m",
            "description": "The additive increment by which x is increased."
          },
          {
            "syntaxName": "a",
            "description": "The array or range containing the coefficients of the power series."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SIN": {
    "header": "SIN",
    "headerDescription": "Returns the sine of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["SIN(PI())", "SIN(1)", "SIN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SIN(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle to find the sine of, in radians."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SINH": {
    "header": "SINH",
    "headerDescription": "Returns the hyperbolic sine of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["SINH(A2)", "SINH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SINH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value to calculate the hyperbolic sine of."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SIGN": {
    "header": "SIGN",
    "headerDescription": "Returns sign of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["SIGN(-42)", "SIGN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SIGN(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value whose sign will be evaluated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SQRT": {
    "header": "SQRT",
    "headerDescription": "Returns the positive square root of a number.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["SQRT(9)", "SQRT(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SQRT(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number for which to calculate the positive square root.          value must be positive; if it is negative, SQRT will return the #NUM! error."
          },
          {
            "syntaxName": "value must be positive; if it is negative, SQRT will return the #NUM! error.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "SQRTPI": {
    "header": "SQRTPI",
    "headerDescription": "Returns sqrt of number times pi.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["SQRTPI(9)", "SQRTPI(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SQRTPI(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The number which will be multiplied by Pi and have the product's square root returned          value must be positive; if it is negative, SQRTPI will return the #NUM! error."
          },
          {
            "syntaxName": "value must be positive; if it is negative, SQRTPI will return the #NUM! error.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUBTOTAL": {
    "header": "SUBTOTAL",
    "headerDescription": "Computes aggregation using function specified by number.",
    "type": "Math",
    "parameters": ["function_code", "range1", "[range2, ..]"],
    "codeSyntaxUsage": ["SUBTOTAL(1,A2:A5,B2:B8)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUBTOTAL(function_code, range1, [range2, ...])",
        "values": [
          {
            "syntaxName": "function_code",
            "description": "The function to use in subtotal aggregation.                  1 is AVERAGE                    2 is COUNT                    3 is COUNTA                    4 is MAX                    5 is MIN                    6 is PRODUCT                    7 is STDEV                    8 is STDEVP                    9 is SUM                    10 is VAR                    11 is VARP                    Hidden values can be skipped for any of these codes by prepending 10 (to the single-digit codes) or 1 (to the 2-digit codes). e.g. 102 for COUNT while skipping hidden cells, and 110 for VAR while doing so."
          },
          { "syntaxName": "1 is AVERAGE", "description": "" },
          { "syntaxName": "2 is COUNT", "description": "" },
          { "syntaxName": "3 is COUNTA", "description": "" },
          { "syntaxName": "4 is MAX", "description": "" },
          { "syntaxName": "5 is MIN", "description": "" },
          { "syntaxName": "6 is PRODUCT", "description": "" },
          { "syntaxName": "7 is STDEV", "description": "" },
          { "syntaxName": "8 is STDEVP", "description": "" },
          { "syntaxName": "9 is SUM", "description": "" },
          { "syntaxName": "10 is VAR", "description": "" },
          { "syntaxName": "11 is VARP", "description": "" },
          {
            "syntaxName": "Hidden values can be skipped for any of these codes by prepending 10 (to the single-digit codes) or 1 (to the 2-digit codes). e.g. 102 for COUNT while skipping hidden cells, and 110 for VAR while doing so.",
            "description": ""
          },
          {
            "syntaxName": "range1",
            "description": "The first range over which to calculate a subtotal."
          },
          {
            "syntaxName": "range2, ...",
            "description": "Additional ranges over which to calculate subtotals."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUM": {
    "header": "SUM",
    "headerDescription": "Adds all the numbers in a range of cells.",
    "type": "Math",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["SUM(A2:A100)", "SUM(1,2,3,4,5)", "SUM(1,2,A2:A50)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUM(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first number or range to add together."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "SUMIF": {
    "header": "SUMIF",
    "headerDescription": "Adds the cells specified by given criteria.",
    "type": "Math",
    "parameters": ["range", "criterion", "[sum_range]"],
    "codeSyntaxUsage": [
      "SUMIF(A1:A10,\"\">20\"\")",
      "SUMIF(A1:A10,'Paid',B1:B10)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMIF(range, criterion, [sum_range])",
        "values": [
          {
            "syntaxName": "range",
            "description": "The range which is tested against criterion."
          },
          {
            "syntaxName": "criterion",
            "description": "The pattern or test to apply to range.                  If range contains text to check against, criterion must be a string. criterion can contain wildcards including ? to match any single character or * to match zero or more contiguous characters. To match an actual question mark or asterisk, prefix the character with the tilde (~) character (i.e. ~? and ~*). A string criterion must be enclosed in quotation marks. Each cell in range is then checked against criterion for equality (or match, if wildcards are used).                    If range contains numbers to check against, criterion may be either a string or a number. If a number is provided, each cell in range is checked for equality with criterion. Otherwise, criterion may be a string containing a number (which also checks for equality), or a number prefixed with any of the following operators: = (checks for equality), > (checks that the range cell value is greater than the criterion value), or < (checks that the range cell value is less than the criterion value)"
          },
          {
            "syntaxName": "If range contains text to check against, criterion must be a string. criterion can contain wildcards including ? to match any single character or * to match zero or more contiguous characters. To match an actual question mark or asterisk, prefix the character with the tilde (~) character (i.e. ~? and ~*). A string criterion must be enclosed in quotation marks. Each cell in range is then checked against criterion for equality (or match, if wildcards are used).",
            "description": ""
          },
          {
            "syntaxName": "If range contains numbers to check against, criterion may be either a string or a number. If a number is provided, each cell in range is checked for equality with criterion. Otherwise, criterion may be a string containing a number (which also checks for equality), or a number prefixed with any of the following operators: = (checks for equality), > (checks that the range cell value is greater than the criterion value), or < (checks that the range cell value is less than the criterion value)",
            "description": ""
          },
          {
            "syntaxName": "sum_range",
            "description": "The range to be summed, if different from range."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUMIFS": {
    "header": "SUMIFS",
    "headerDescription": "Returns the sum of the values of cells in a range that meets multiple criteria in multiple ranges.",
    "type": "Math",
    "parameters": [
      "sum_range",
      "criteria_range1",
      "criterion1",
      "[criteria_range2, criterion2, ..]"
    ],
    "codeSyntaxUsage": [
      "SUMIFS(A1:A10, B1:B10, \"\">20\"\")",
      "SUMIFS(A1:A10, B1:B10, \"\">20\"\", C1:C10, \"\"<30\"\")",
      "SUMIFS(C1:C100, E1:E100, \"\"Yes\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMIFS(sum_range, criteria_range1, criterion1, [criteria_range2, criterion2, ...])",
        "values": [
          {
            "syntaxName": "sum_range",
            "description": "The range to be summed."
          },
          {
            "syntaxName": "criteria_range1",
            "description": "The range to be checked against criterion1."
          },
          {
            "syntaxName": "criterion1",
            "description": "The pattern or test to apply to criteria_range1."
          },
          {
            "syntaxName": "criteria_range2, criterion2, …",
            "description": "[ OPTIONAL ]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUMPRODUCT": {
    "header": "SUMPRODUCT",
    "headerDescription": "Multiplies corresponding elements in the given arrays, and returns the sum of those products.",
    "type": "Array",
    "parameters": ["array1", "[array2, ..]"],
    "codeSyntaxUsage": [
      "SUMPRODUCT(A2:C5,D2:F5)",
      "SUMPRODUCT({1,2,3,4},{5,6,7,8})"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMPRODUCT(array1, [array2, ...])",
        "values": [
          {
            "syntaxName": "array1",
            "description": "The first array or range whose entries will be multiplied with corresponding entries in the second such array or range."
          },
          { "syntaxName": "array2, …", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "SUMSQ": {
    "header": "SUMSQ",
    "headerDescription": "Returns the sum of the squares of the arguments",
    "type": "Math",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "SUMSQ(A2:A100)",
      "SUMSQ(1,2,3,4,5)",
      "SUMSQ(1,2,A2:A50)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMSQ(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first number or range whose squares to add together."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "SUMX2MY2": {
    "header": "SUMX2MY2",
    "headerDescription": "Returns the sum of the square differences.",
    "type": "Array",
    "parameters": ["array_x", "array_y"],
    "codeSyntaxUsage": ["SUMX2MY2({1,2,3},{4,5,6})", "SUMX2MY2(A2:A9,B2:B9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMX2MY2(array_x, array_y)",
        "values": [
          {
            "syntaxName": "array_x",
            "description": "The array or range of values whose squares will be reduced by the squares of corresponding entries in array_y and added together."
          },
          {
            "syntaxName": "array_y",
            "description": "The array or range of values whose squares will be subtracted from the squares of corresponding entries in array_x and added together."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUMX2PY2": {
    "header": "SUMX2PY2",
    "headerDescription": "Returns the sum of the square sums.",
    "type": "Array",
    "parameters": ["array_x", "array_y"],
    "codeSyntaxUsage": ["SUMX2PY2({1,2,3},{4,5,6})", "SUMX2PY2(A2:A9,B2:B9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMX2PY2(array_x, array_y)",
        "values": [
          {
            "syntaxName": "array_x",
            "description": "The array or range of values whose squares will be added to the squares of corresponding entries in array_y and added together."
          },
          {
            "syntaxName": "array_y",
            "description": "The array or range of values whose squares will be added to the squares of corresponding entries in array_x and added together."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SUMXMY2": {
    "header": "SUMXMY2",
    "headerDescription": "Returns the sum of the square of differences.",
    "type": "Array",
    "parameters": ["array_x", "array_y"],
    "codeSyntaxUsage": ["SUMXMY2({1,2,3},{4,5,6})", "SUMXMY2(A2:A9,B2:B9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUMXMY2(array_x, array_y)",
        "values": [
          {
            "syntaxName": "array_x",
            "description": "The array or range of values that will be reduced by corresponding entries in array_y, squared and added together."
          },
          {
            "syntaxName": "array_y",
            "description": "The array or range of values that will be subtracted from corresponding entries in array_x, the result squared and all such results added together."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TAN": {
    "header": "TAN",
    "headerDescription": "Returns the tangent of the given angle (in radians).",
    "type": "Math",
    "parameters": ["angle"],
    "codeSyntaxUsage": ["TAN(PI())", "TAN(A2)", "TAN(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TAN(angle)",
        "values": [
          {
            "syntaxName": "angle",
            "description": "The angle to find the tangent of, in radians."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TANH": {
    "header": "TANH",
    "headerDescription": "Returns the hyperbolic tangent of the given value.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["TANH(A2)", "TANH(1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TANH(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "Any real value to calculate the hyperbolic tangent of."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TRUNC": {
    "header": "TRUNC",
    "headerDescription": "Truncates a number by removing decimal places.",
    "type": "Math",
    "parameters": ["value", "[places]"],
    "codeSyntaxUsage": ["TRUNC(3.141592654,2)", "TRUNC(A2,0)", "TRUNC(1.23)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TRUNC(value, [places])",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value to be truncated."
          },
          { "syntaxName": "places", "description": "[ OPTIONAL" },
          {
            "syntaxName": "If places is greater than the number of significant digits in value, value is returned without modification.",
            "description": ""
          },
          {
            "syntaxName": "places may be negative, in which case the specified number of digits to the left of the decimal place are changed to zero. All digits to the right of the decimal place are discarded. If all digits of value are changed to zero, TRUNC simply returns 0.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "MMULT": {
    "header": "MMULT",
    "headerDescription": "Calculates the array product of two arrays.",
    "type": "Array",
    "parameters": ["matrix1", "matrix2"],
    "codeSyntaxUsage": ["MMULT(A1:B3,C1:F2)", "MMULT({1,2,3;4,5,6},{7;8;9})"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MMULT(matrix1, matrix2)",
        "values": [
          {
            "syntaxName": "matrix1",
            "description": "The first matrix in the matrix multiplication operation, represented as an array or range."
          },
          {
            "syntaxName": "matrix2",
            "description": "The second matrix in the matrix multiplication operation, represented as an array or range."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TRANSPOSE": {
    "header": "TRANSPOSE",
    "headerDescription": "Transposes the rows and columns of an array.",
    "type": "Array",
    "parameters": ["array_or_range"],
    "codeSyntaxUsage": ["TRANSPOSE({1,2;3,4;5,6})", "TRANSPOSE(A2:F9)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TRANSPOSE(array_or_range)",
        "values": [
          {
            "syntaxName": "array_or_range",
            "description": "The array or range whose rows and columns will be swapped."
          }
        ]
      }
    ],
    "attributes": []
  },
  "AVEDEV": {
    "header": "AVEDEV",
    "headerDescription": "Returns the average deviation of the arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["AVEDEV(1,2,3,4,5,6,7,8,9,10)", "AVEDEV(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "AVEDEV(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the sample."
          }
        ]
      }
    ],
    "attributes": []
  },
  "AVERAGE": {
    "header": "AVERAGE",
    "headerDescription": "Returns the average of the arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "AVERAGE(A2:A100,B2:B100,4,26)",
      "AVERAGE(1,2,3,4,5,C6:C20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "AVERAGE(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the average value."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "AVERAGEA": {
    "header": "AVERAGEA",
    "headerDescription": "Returns the average of the arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "AVERAGEA(A2:A100,B2:B100,4,26)",
      "AVERAGEA(1,2,3,4,5,C6:C20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "AVERAGEA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the average value."
          },
          {
            "syntaxName": "value2, ... - [ OPTIONAL ] - Additional values or ranges to consider when calculating the average value.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "AVERAGEIF": {
    "header": "AVERAGEIF",
    "headerDescription": "Returns the arithmetic mean of all cells in a range that satisfy a given condition.",
    "type": "Statistical",
    "parameters": ["criteria_range", "criterion", "[average_range]"],
    "codeSyntaxUsage": [
      "AVERAGEIF(A1:A10, \"\">20\"\", B1:B10)",
      "AVERAGEIF(A1:A10, \"\"<10\"\")",
      "AVERAGEIF(A1:A10, \"\"Paid\"\", B1:B10)",
      "AVERAGEIF(A1:A10, \"\"<\"\"&B1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "AVERAGEIF(criteria_range, criterion, [average_range])",
        "values": [
          {
            "syntaxName": "criteria_range",
            "description": "The range to check against criterion."
          },
          {
            "syntaxName": "criterion",
            "description": "The pattern or test to apply to criteria_range.          Equals: \"\"text\"\" or 1 or \"\"=text\"\" or \"\"=1\"\"      Greater than: \"\">1\"\"      Greater than or equal to: \"\">=1\"\"      Less than: \"\"<1\"\"      Less than or equal to: \"\"<=1\"\"      Not equal to: \"\"<>1\"\" or \"\"<>text\"\""
          },
          {
            "syntaxName": "Equals: \"\"text\"\" or 1 or \"\"=text\"\" or \"\"=1\"\"",
            "description": ""
          },
          { "syntaxName": "Greater than: \"\">1\"\"", "description": "" },
          {
            "syntaxName": "Greater than or equal to: \"\">=1\"\"",
            "description": ""
          },
          { "syntaxName": "Less than: \"\"<1\"\"", "description": "" },
          {
            "syntaxName": "Less than or equal to: \"\"<=1\"\"",
            "description": ""
          },
          {
            "syntaxName": "Not equal to: \"\"<>1\"\" or \"\"<>text\"\"",
            "description": ""
          },
          { "syntaxName": "average_range", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "BETA.DIST": {
    "header": "BETA.DIST",
    "headerDescription": "Returns the denisty of Beta distribution.",
    "type": "Statistical",
    "parameters": [
      "value",
      "alpha",
      "beta",
      "cumulative",
      "lower_bound",
      "upper_bound"
    ],
    "codeSyntaxUsage": [
      "BETA.DIST(0.65, 1.234, 7, 0.5, 3)",
      "BETA.DIST(0.42, 3, 8)",
      "BETA.DIST(0.92, 0.5, 0.7)",
      "BETA.DIST(A5, 0.5, 0.7, -1, 1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BETA.DIST(value, alpha, beta, lower_bound, upper_bound)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value at which to evaluate the probability function.               The given value must be a number from the given lower boundary to the given upper boundary.            "
          },
          {
            "syntaxName": "alpha",
            "description": "The first shape parameter of the distribution.               The given alpha must be a positive number.            "
          },
          {
            "syntaxName": "beta",
            "description": "The second shape parameter of the distribution.               The given beta must be a positive number.            "
          },
          {
            "syntaxName": "lower_bound",
            "description": "The lower boundary of the function.               The default lower boundary is 0.            "
          },
          {
            "syntaxName": "upper-bound",
            "description": "The upper boundary of the function.               The default upper boundary is 1.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "BETADIST": {
    "header": "BETADIST",
    "headerDescription": "Returns the denisty of Beta distribution.",
    "type": "Statistical",
    "parameters": ["value", "alpha", "beta", "lower_bound", "upper_bound"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "BETA.INV": {
    "header": "BETA.INV",
    "headerDescription": "Returns the inverse Beta distribution value.",
    "type": "Statistical",
    "parameters": [
      "probability",
      "alpha",
      "beta",
      "lower_bound",
      "upper_bound"
    ],
    "codeSyntaxUsage": [
      "BETA.INV(0.65,1.234,7,1,3)  BETA.INV(0.3,5,1)  BETA.INV(A4,3,2,-1,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BETA.INV(probability, alpha, beta, lower_bound, upper_bound)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability at which the function will be evaluated. Must be between 0 and 1, inclusive."
          },
          {
            "syntaxName": "alpha",
            "description": "The first shape parameter of the distribution. Must be positive."
          },
          {
            "syntaxName": "beta",
            "description": "The second shape parameter of the distribution. Must be positive."
          },
          {
            "syntaxName": "lower_bound",
            "description": "Lower bound of the original beta distribution’s domain. Default value is 1."
          },
          {
            "syntaxName": "upper-bound",
            "description": "Upper bound of the original beta distributions’s domain. Default value is 1."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BETAINV": {
    "header": "BETAINV",
    "headerDescription": "Returns the inverse of Beta distribution value.",
    "type": "Statistical",
    "parameters": [
      "probability",
      "alpha",
      "beta",
      "lower_bound",
      "upper_bound"
    ],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "BINOM.DIST": {
    "header": "BINOM.DIST",
    "headerDescription": "Returns density of binomial distribution.",
    "type": "Statistical",
    "parameters": ["num_successes", "num_trials", "prob_success", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "BINOMDIST": {
    "header": "BINOMDIST",
    "headerDescription": "Returns density of binomial distribution.",
    "type": "Statistical",
    "parameters": ["num_successes", "num_trials", "prob_success", "cumulative"],
    "codeSyntaxUsage": [
      "BINOMDIST(4,100,0.005,FALSE)",
      "BINOMDIST(A2,A3,A4,TRUE)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "BINOMDIST(num_successes, num_trials, prob_success, cumulative)",
        "values": [
          {
            "syntaxName": "num_successes",
            "description": "The number of successes for which to calculate the probability in num_trials trials.          If cumulative is TRUE, then BINOMDIST returns the probability of num_successes or fewer successes, otherwise the probability of exactly num_successes successes."
          },
          {
            "syntaxName": "If cumulative is TRUE, then BINOMDIST returns the probability of num_successes or fewer successes, otherwise the probability of exactly num_successes successes.",
            "description": ""
          },
          {
            "syntaxName": "num_trials",
            "description": "The number of independent trials."
          },
          {
            "syntaxName": "prob_success",
            "description": "The probability of success in any given trial."
          },
          {
            "syntaxName": "cumulative",
            "description": "[ FALSE by default ] - Whether to use the binomial cumulative distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "BINOM.INV": {
    "header": "BINOM.INV",
    "headerDescription": "Returns inverse binomial distribution value.",
    "type": "Statistical",
    "parameters": ["num_trials", "prob_success", "target_prob"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "CHIDIST": {
    "header": "CHIDIST",
    "headerDescription": "Returns probability of chi-square right-side distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom"],
    "codeSyntaxUsage": ["CHIDIST(3.45, 2)", "CHIDIST(A2, B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHIDIST(x, degrees_freedom)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the chi-squared probability distribution function. The value at which to evaluate the function.                  Must be a positive number."
          },
          { "syntaxName": "Must be a positive number.", "description": "" },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHIINV": {
    "header": "CHIINV",
    "headerDescription": "Returns inverse of chi-square right-side distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": ["CHIINV(0.42, 2)", "CHIINV(A2, B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHIINV(probability, degrees_freedom)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the right-tailed chi-squared distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHISQ.DIST": {
    "header": "CHISQ.DIST",
    "headerDescription": "Returns value of chi-square distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom", "cumulative"],
    "codeSyntaxUsage": [
      "CHISQ.DIST(3.45, 2, TRUE)",
      "CHISQ.DIST(A2, B2, TRUE)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHISQ.DIST(x, degrees_freedom, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the chi-squared probability distribution function. The value at which to evaluate the function.                  Must be a positive number."
          },
          { "syntaxName": "Must be a positive number.", "description": "" },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          },
          {
            "syntaxName": "cumulative",
            "description": "Logical value that determines the form of the function.                  If TRUE: CHI.DIST returns the left-tailed cumulative distribution function.                    If FALSE: CHI.DIST returns the probability density function."
          },
          {
            "syntaxName": "If TRUE: CHI.DIST returns the left-tailed cumulative distribution function.",
            "description": ""
          },
          {
            "syntaxName": "If FALSE: CHI.DIST returns the probability density function.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHISQ.DIST.RT": {
    "header": "CHISQ.DIST.RT",
    "headerDescription": "Returns probability of chi-square right-side distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom"],
    "codeSyntaxUsage": ["CHISQ.DIST.RT(3.45, 2)", "CHISQ.DIST.RT(A2, B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHISQ.DIST.RT(x, degrees_freedom)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the chi-squared probability distribution function. The value at which to evaluate the function.                  Must be a positive number."
          },
          { "syntaxName": "Must be a positive number.", "description": "" },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHISQ.INV": {
    "header": "CHISQ.INV",
    "headerDescription": "Returns inverse of chi-square distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": ["CHISQ.INV(0.42, 2)", "CHISQ.INV(A2, B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHISQ.INV(probability, degrees_freedom)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the left-tailed chi-squared distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHISQ.INV.RT": {
    "header": "CHISQ.INV.RT",
    "headerDescription": "Returns inverse of chi-square right-side distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": ["CHISQ.INV.RT(0.42, 2)", "CHISQ.INV.RT(A2, B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHISQ.INV.RT(probability, degrees_freedom)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the right-tailed chi-squared distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom of the distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CHISQ.TEST": {
    "header": "CHISQ.TEST",
    "headerDescription": "Returns chisquared-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["observed_range", "expected_range"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "CHITEST": {
    "header": "CHITEST",
    "headerDescription": "Returns chisquared-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["observed_range", "expected_range"],
    "codeSyntaxUsage": ["CHITEST(A1:A5, B1:B5)", "CHITEST(A1:D3, A5:D7)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHITEST(observed_range, expected_range)",
        "values": [
          {
            "syntaxName": "observed_range",
            "description": "The counts associated with each category of data."
          },
          {
            "syntaxName": "expected_range",
            "description": "The expected counts for each category under the null hypothesis."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CONFIDENCE": {
    "header": "CONFIDENCE",
    "headerDescription": "Returns upper confidence bound for normal distribution.",
    "type": "Statistical",
    "parameters": ["alpha", "standard_deviation", "pop_size"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "CONFIDENCE.NORM": {
    "header": "CONFIDENCE.NORM",
    "headerDescription": "Returns upper confidence bound for normal distribution.",
    "type": "Statistical",
    "parameters": ["alpha", "standard_deviation", "pop_size"],
    "codeSyntaxUsage": [
      "CONFIDENCE.NORM(0.05,1.6,250)",
      "CONFIDENCE.NORM(A2,A3,A4)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CONFIDENCE.NORM(alpha, standard_deviation, pop_size)",
        "values": [
          {
            "syntaxName": "alpha",
            "description": "One minus the desired confidence level. E.g. 0.1 for 0.9 or 90%, confidence."
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation of the population."
          },
          {
            "syntaxName": "pop_size",
            "description": "The size of the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CONFIDENCE.T": {
    "header": "CONFIDENCE.T",
    "headerDescription": "Returns upper confidence bound for T distribution.",
    "type": "Statistical",
    "parameters": ["alpha", "standard_deviation", "size"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CONFIDENCE.T(alpha, standard_deviation, size) ",
        "values": [
          {
            "syntaxName": "alpha ",
            "description": "      One minus the desired confidence level. E.g. 0.1 for 0.9, or 90%, confidence.      "
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation of the population. "
          },
          {
            "syntaxName": "size",
            "description": "The size of the population. "
          }
        ]
      }
    ],
    "attributes": []
  },
  "CORREL": {
    "header": "CORREL",
    "headerDescription": "Returns the correlation coefficient between two data sets.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["CORREL(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CORREL(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COUNT": {
    "header": "COUNT",
    "headerDescription": "Counts how many numbers are in the list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "COUNT(A2:A100,B2:B100,4,26)",
      "COUNT(1,2,3,4,5,C6:C20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNT(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when counting."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "COUNTA": {
    "header": "COUNTA",
    "headerDescription": "Counts how many values are in the list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "COUNTA(A2:A100,B2:B100,4,26)",
      "COUNTA(1,2,3,4,5,C6:C20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNTA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when counting."
          },
          { "syntaxName": "value2, ...", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "COUNTBLANK": {
    "header": "COUNTBLANK",
    "headerDescription": "Returns the number of empty cells.",
    "type": "Math",
    "parameters": ["range"],
    "codeSyntaxUsage": ["COUNTBLANK(A2:C100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNTBLANK(value1, [value2,...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range in which the number of blanks is counted."
          },
          { "syntaxName": "value2", "description": "[OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "COUNTIF": {
    "header": "COUNTIF",
    "headerDescription": "Returns the number of cells that meet with certain criteria within a cell range.",
    "type": "Math",
    "parameters": ["range", "criterion"],
    "codeSyntaxUsage": [
      "COUNTIF(A1:A10,\"\">20\"\")",
      "COUNTIF(A1:A10,\"\"Paid\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNTIF(range, criterion)",
        "values": [
          {
            "syntaxName": "range",
            "description": "The range that is tested against criterion."
          },
          {
            "syntaxName": "criterion",
            "description": "The pattern or test to apply to range.                  If range contains text to check against, criterion must be a string. criterion can contain wildcards including ? to match any single character or * to match zero or more contiguous characters. To match an actual question mark or asterisk, prefix the character with the tilde (~) character (i.e. ~? and ~*). A string criterion must be enclosed in quotation marks. Each cell in range is then checked against criterion for equality (or match, if wildcards are used).                    If range contains numbers to check against, criterion may be either a string or a number. If a number is provided, each cell in range is checked for equality with criterion. Otherwise, criterion may be a string containing a number (which also checks for equality), or a number prefixed with any of the following operators: =, >, >=, <, or <=, which check whether the range cell is equal to, greater than, greater than or equal to, less than, or less than or equal to the criterion value, respectively."
          },
          {
            "syntaxName": "If range contains text to check against, criterion must be a string. criterion can contain wildcards including ? to match any single character or * to match zero or more contiguous characters. To match an actual question mark or asterisk, prefix the character with the tilde (~) character (i.e. ~? and ~*). A string criterion must be enclosed in quotation marks. Each cell in range is then checked against criterion for equality (or match, if wildcards are used).",
            "description": ""
          },
          {
            "syntaxName": "If range contains numbers to check against, criterion may be either a string or a number. If a number is provided, each cell in range is checked for equality with criterion. Otherwise, criterion may be a string containing a number (which also checks for equality), or a number prefixed with any of the following operators: =, >, >=, <, or <=, which check whether the range cell is equal to, greater than, greater than or equal to, less than, or less than or equal to the criterion value, respectively.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "COUNTIFS": {
    "header": "COUNTIFS",
    "headerDescription": "Returns the count of rows or columns that meet criteria in multiple ranges.",
    "type": "Math",
    "parameters": [
      "criteria_range1",
      "criterion1",
      "[criteria_range2, criterion2, ..]"
    ],
    "codeSyntaxUsage": [
      "COUNTIFS(A1:A10, \"\">20\"\", B1:B10, \"\"<30\"\")",
      "COUNTIFS(A7:A24, \"\">6\"\", B7:B24, \"\"<\"\"&DATE(1969,7,20))",
      "COUNTIFS(B8:B27, \"\">\"\" & B12, C8:C27, \"\"<\"\" & C13, D8:D27, “<>10”)",
      "COUNTIFS(C1:C100, \"\"Yes\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COUNTIFS(criteria_range1, criterion1, [criteria_range2, criterion2, ...])",
        "values": [
          {
            "syntaxName": "criteria_range1",
            "description": "The range to be checked against criterion1."
          },
          {
            "syntaxName": "criterion1",
            "description": "The pattern or test to be applied to criteria_range1."
          },
          {
            "syntaxName": "criteria_range2, criterion2…",
            "description": "[ OPTIONAL ]"
          }
        ]
      }
    ],
    "attributes": []
  },
  "COVAR": {
    "header": "COVAR",
    "headerDescription": "Returns the covariance between two data sets, population normalized.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["COVAR(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COVAR(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "COVARIANCE.P": {
    "header": "COVARIANCE.P",
    "headerDescription": "Returns the covariance between two data sets, population normalized.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "COVARIANCE.S": {
    "header": "COVARIANCE.S",
    "headerDescription": "Returns the covariance between two data sets, sample normalized.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["A10)", "COVARIANCE.S(1, 2, 3, 4)", "B5, 10)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "COVARIANCE.S(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CRITBINOM": {
    "header": "CRITBINOM",
    "headerDescription": "Returns inverse binomial distribution value.",
    "type": "Statistical",
    "parameters": ["num_trials", "prob_success", "target_prob"],
    "codeSyntaxUsage": ["CRITBINOM(100,0.005,0.8)", "CRITBINOM(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CRITBINOM(num_trials, prob_success, target_prob)",
        "values": [
          {
            "syntaxName": "num_trials",
            "description": "The number of independent trials."
          },
          {
            "syntaxName": "prob_success",
            "description": "The probability of success in any given trial."
          },
          {
            "syntaxName": "target_prob",
            "description": "The desired threshold probability."
          }
        ]
      }
    ],
    "attributes": []
  },
  "DEVSQ": {
    "header": "DEVSQ",
    "headerDescription": "Returns sum of squared deviations.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["DEVSQ(1,2,3,4,5,6,7,8,9,10)", "DEVSQ(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "DEVSQ(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the sample."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EXPON.DIST": {
    "header": "EXPON.DIST",
    "headerDescription": "Returns density of a exponential distribution.",
    "type": "Statistical",
    "parameters": ["x", "lambda", "cumulative"],
    "codeSyntaxUsage": ["EXPON.DIST(4,0.5,FALSE)", "EXPON.DIST(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "EXPON.DIST(x, lambda, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the exponential distribution function.          If cumulative is TRUE then EXPON.DIST returns the cumulative probability of all values up to x."
          },
          {
            "syntaxName": "If cumulative is TRUE then EXPON.DIST returns the cumulative probability of all values up to x.",
            "description": ""
          },
          {
            "syntaxName": "lambda",
            "description": "The lambda to specify the exponential distribution function."
          },
          {
            "syntaxName": "cumulative",
            "description": "Whether to use the exponential cumulative distribution."
          }
        ]
      }
    ],
    "attributes": []
  },
  "EXPONDIST": {
    "header": "EXPONDIST",
    "headerDescription": "Returns density of a exponential distribution.",
    "type": "Statistical",
    "parameters": ["x", "lambda", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "FDIST": {
    "header": "FDIST",
    "headerDescription": "Returns probability of F right-side distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom1", "degrees_freedom2"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "FINV": {
    "header": "FINV",
    "headerDescription": "Returns inverse of F right-side distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom1", "degrees_freedom2"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "F.DIST": {
    "header": "F.DIST",
    "headerDescription": "Returns value of F distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom1", "degrees_freedom2", "cumulative"],
    "codeSyntaxUsage": [
      "F.DIST(15.35, 7, 6, TRUE)",
      "F.DIST(A2, B2, C2, FALSE)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "F.DIST(x, degrees_freedom1, degrees_freedom2, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the F probability distribution function. The value at which to evaluate the function.                  Must be a positive number."
          },
          { "syntaxName": "Must be a positive number.", "description": "" },
          {
            "syntaxName": "degrees_freedom1",
            "description": "the numerator degrees of freedom."
          },
          {
            "syntaxName": "degrees_freedom2",
            "description": "the denominator degrees of freedom."
          },
          {
            "syntaxName": "cumulative",
            "description": "logical value that determines the form of the function. Default value is FALSE.                  If TRUE: F.DIST returns the cumulative distribution function.                    If FALSE: F.DIST returns the probability density function."
          },
          {
            "syntaxName": "If TRUE: F.DIST returns the cumulative distribution function.",
            "description": ""
          },
          {
            "syntaxName": "If FALSE: F.DIST returns the probability density function.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "F.DIST.RT": {
    "header": "F.DIST.RT",
    "headerDescription": "Returns probability of F right-side distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom1", "degrees_freedom2"],
    "codeSyntaxUsage": ["F.DIST.RT(15.35, 7, 6)", "F.DIST.RT(A2, B2, C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "F.DIST.RT(x, degrees_freedom1, degrees_freedom2)",
        "values": [
          {
            "syntaxName": "x",
            "description": "the input to the F probability distribution function. The value at which to evaluate the function.                  Must be a positive number."
          },
          { "syntaxName": "Must be a positive number.", "description": "" },
          {
            "syntaxName": "degrees_freedom1",
            "description": "the numerator of the number of degrees of freedom."
          },
          {
            "syntaxName": "degrees_freedom2",
            "description": "the denominator of the number of degrees of freedom."
          }
        ]
      }
    ],
    "attributes": []
  },
  "F.INV": {
    "header": "F.INV",
    "headerDescription": "Returns inverse of F distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom1", "degrees_freedom2"],
    "codeSyntaxUsage": ["F.INV(0.42, 2, 3)", "F.INV(A2, B2, C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "F.INV(probability, degrees_freedom1, degrees_freedom2)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the left-tailed F-distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom1",
            "description": "The number of degrees of freedom of the numerator of the test statistic."
          },
          {
            "syntaxName": "degrees_freedom2",
            "description": "The number of degrees of freedom of the denominator of the test statistic."
          }
        ]
      }
    ],
    "attributes": []
  },
  "F.INV.RT": {
    "header": "F.INV.RT",
    "headerDescription": "Returns inverse of F right-side distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom1", "degrees_freedom2"],
    "codeSyntaxUsage": ["F.INV.RT(0.42, 2, 3)", "F.INV.RT(A2, B2, C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "F.INV.RT(probability, degrees_freedom1, degrees_freedom2)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the right-tailed F-distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom1",
            "description": "The number of degrees of freedom of the numerator of the test statistic."
          },
          {
            "syntaxName": "degrees_freedom2",
            "description": "The number of degrees of freedom of the denominator of the test statistic."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FISHER": {
    "header": "FISHER",
    "headerDescription": "Returns Fisher transformation value.",
    "type": "Statistical",
    "parameters": ["value"],
    "codeSyntaxUsage": ["FISHER(0.962)", "FISHER(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FISHER(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which to calculate the Fisher transformation."
          }
        ]
      }
    ],
    "attributes": []
  },
  "FISHERINV": {
    "header": "FISHERINV",
    "headerDescription": "Returns inverse Fischer transformation value.",
    "type": "Statistical",
    "parameters": ["value"],
    "codeSyntaxUsage": ["FISHERINV(0.962)", "FISHERINV(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FISHERINV(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The value for which to calculate the inverse Fisher transformation."
          }
        ]
      }
    ],
    "attributes": []
  },
  "F.TEST": {
    "header": "F.TEST",
    "headerDescription": "Returns f-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["range1", "range2"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "FTEST": {
    "header": "FTEST",
    "headerDescription": "Returns f-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["range1", "range2"],
    "codeSyntaxUsage": ["FTEST(A1:A5, B1:B5)", "FTEST(A1:D3, A5:D7)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FTEST(range1, range2)",
        "values": [
          {
            "syntaxName": "range1",
            "description": "The first sample of data or group of cells to consider for the F-test."
          },
          {
            "syntaxName": "range2",
            "description": "The second sample of data or group of cells to consider for the F-test."
          }
        ]
      }
    ],
    "attributes": []
  },
  "GAMMA": {
    "header": "GAMMA",
    "headerDescription": "Returns value of Gamma function.",
    "type": "Statistical",
    "parameters": ["number"],
    "codeSyntaxUsage": ["A10)", "GAMMA(1, 2, 3, 4)", "B5, 10)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GAMMA(number) ",
        "values": [
          {
            "syntaxName": "number",
            "description": "The input to the Gamma function. The natural logarithm of Gamma (number) will be returned.      The number must be positive."
          }
        ]
      }
    ],
    "attributes": []
  },
  "GAMMA.DIST": {
    "header": "GAMMA.DIST",
    "headerDescription": "Returns density of Gamma distribution.",
    "type": "Statistical",
    "parameters": ["x", "alpha", "beta", "cumulative"],
    "codeSyntaxUsage": [
      "GAMMA.DIST(4.79, 1.234, 7, TRUE)",
      "GAMMA.DIST(A1, B1, C1, FALSE)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GAMMA.DIST(x, alpha, beta, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the gamma probability distribution function. The value at which to evaluate the function."
          },
          {
            "syntaxName": "alpha",
            "description": "The first parameter of the distribution."
          },
          {
            "syntaxName": "beta",
            "description": "The second parameter of the distribution."
          },
          {
            "syntaxName": "cumulative",
            "description": "Logical value that determines the form of the function.                  If TRUE: GAMMA.DIST returns the left-tailed cumulative distribution function.                    If FALSE: GAMMA.DIST returns the probability density function."
          },
          {
            "syntaxName": "If TRUE: GAMMA.DIST returns the left-tailed cumulative distribution function.",
            "description": ""
          },
          {
            "syntaxName": "If FALSE: GAMMA.DIST returns the probability density function.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "GAMMADIST": {
    "header": "GAMMADIST",
    "headerDescription": "Returns density of Gamma distribution.",
    "type": "Statistical",
    "parameters": ["x", "alpha", "beta", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "GAMMALN": {
    "header": "GAMMALN",
    "headerDescription": "Returns natural logarithm of Gamma function.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": ["GAMMALN(4)", "GAMMALN(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GAMMALN(value)",
        "values": [
          {
            "syntaxName": "value - The input to the Gamma function. The natural logarithm of Gamma (value) will be returned.          value must be positive.",
            "description": ""
          },
          { "syntaxName": "value must be positive.", "description": "" }
        ]
      }
    ],
    "attributes": []
  },
  "GAMMALN.PRECISE": {
    "header": "GAMMALN.PRECISE",
    "headerDescription": "Returns natural logarithm of Gamma function.",
    "type": "Math",
    "parameters": ["value"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "GAMMA.INV": {
    "header": "GAMMA.INV",
    "headerDescription": "Returns inverse Gamma distribution value.",
    "type": "Statistical",
    "parameters": ["probability", "alpha", "beta"],
    "codeSyntaxUsage": ["GAMMA.INV(0.65, 4, 2)", "GAMMA.INV(C3, 3, 2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GAMMA.INV(probability, alpha, beta)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The input to the inverse gamma distribution function.               Must be between 0 and 1.            "
          },
          {
            "syntaxName": "alpha",
            "description": "The shape of the gamma distribution.               Must be positive.        The sign of significance is ignored.            "
          },
          {
            "syntaxName": "beta",
            "description": "The inverse-scale of the gamma distribution.               Must be positive.            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "GAMMAINV": {
    "header": "GAMMAINV",
    "headerDescription": "Returns inverse Gamma distribution value.",
    "type": "Statistical",
    "parameters": ["probability", "alpha", "beta"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "GAUSS": {
    "header": "GAUSS",
    "headerDescription": "Returns the probability of gaussian variable fall more than this many times standard deviation from mean.",
    "type": "Statistical",
    "parameters": ["z"],
    "codeSyntaxUsage": ["GAUSS(1)", "GAUSS(B2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GAUSS(z)",
        "values": [
          {
            "syntaxName": "z",
            "description": "The number of standard deviations from the mean.               The parameter z represents how far away from the mean a random variable might fall.        A normal distribution is characterised by a mean (μ) and a standard deviation (z * σ).            "
          }
        ]
      }
    ],
    "attributes": []
  },
  "GEOMEAN": {
    "header": "GEOMEAN",
    "headerDescription": "Returns the geometric average.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["GEOMEAN(1,2,3,4,5,6,7,8,9,10)", "GEOMEAN(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "GEOMEAN(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "HARMEAN": {
    "header": "HARMEAN",
    "headerDescription": "Returns the harmonic average.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["HARMEAN(1,2,3,4,5,6,7,8,9,10)", "HARMEAN(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HARMEAN(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "HYPGEOMDIST": {
    "header": "HYPGEOMDIST",
    "headerDescription": "Returns density of hypergeometric distribution.",
    "type": "Statistical",
    "parameters": [
      "num_successes",
      "num_draws",
      "successes_in_pop",
      "pop_size"
    ],
    "codeSyntaxUsage": ["HYPGEOMDIST(4,12,20,40)", "HYPGEOMDIST(A2,A3,A4,A5)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "HYPGEOMDIST(num_successes, num_draws, successes_in_pop, pop_size)",
        "values": [
          {
            "syntaxName": "num_successes",
            "description": "The desired number of successes."
          },
          {
            "syntaxName": "num_draws",
            "description": "The number of permitted draws."
          },
          {
            "syntaxName": "successes_in_pop",
            "description": "The total number of successes in the population."
          },
          {
            "syntaxName": "pop_size",
            "description": "The total size of the population"
          }
        ]
      }
    ],
    "attributes": []
  },
  "HYPGEOM.DIST": {
    "header": "HYPGEOM.DIST",
    "headerDescription": "Returns density of hypergeometric distribution.",
    "type": "Statistical",
    "parameters": [
      "num_successes",
      "num_draws",
      "successes_in_pop",
      "pop_size"
    ],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "LARGE": {
    "header": "LARGE",
    "headerDescription": "Returns k-th largest value in a range.",
    "type": "Statistical",
    "parameters": ["data", "n"],
    "codeSyntaxUsage": ["LARGE(A2:B100,4)", "LARGE(A2:B100,C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LARGE(data, n)",
        "values": [
          {
            "syntaxName": "data",
            "description": "The array or range containing the data set to consider."
          },
          {
            "syntaxName": "n",
            "description": "The rank from largest to smallest of the element to return.          For example, setting n to 4 will cause LARGE to return the 4th largest element from data."
          },
          {
            "syntaxName": "For example, setting n to 4 will cause LARGE to return the 4th largest element from data.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "LOGNORM.DIST": {
    "header": "LOGNORM.DIST",
    "headerDescription": "Returns density of lognormal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "LOGNORMDIST": {
    "header": "LOGNORMDIST",
    "headerDescription": "Returns density of lognormal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": ["LOGNORMDIST(4,4,6)", "LOGNORMDIST(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LOGNORMDIST(x, mean, standard_deviation)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the log-normal cumulative distribution function."
          },
          {
            "syntaxName": "mean",
            "description": "The mean (mu) of the log-normal cumulative distribution function."
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation (sigma) of the log-normal cumulative distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "LOGNORM.INV": {
    "header": "LOGNORM.INV",
    "headerDescription": "Returns value of inverse lognormal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "LOGINV": {
    "header": "LOGINV",
    "headerDescription": "Returns value of inverse lognormal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": ["LOGINV(0.4,4,6)", "LOGINV(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LOGINV(x, mean, standard_deviation)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the inverse log-normal cumulative distribution function."
          },
          {
            "syntaxName": "mean",
            "description": "The mean (mu) of the inverse log-normal cumulative distribution function."
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation (sigma) of the inverse log-normal cumulative distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "MAX": {
    "header": "MAX",
    "headerDescription": "Returns the maximum value in a list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["MAX(A2:A100,B2:B100,4,26)", "MAX(1,2,3,4,5,C6:C20)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MAX(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the maximum value."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "MAXA": {
    "header": "MAXA",
    "headerDescription": "Returns the maximum value in a list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["MAXA(A2:A100,B2:B100,4,26)", "MAXA(1,2,3,4,5,C6:C20)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MAXA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the maximum value."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "MEDIAN": {
    "header": "MEDIAN",
    "headerDescription": "Returns the median of a set of numbers.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [
      "MEDIAN(A2:A100,B2:B100,4,26)",
      "MEDIAN(1,2,3,4,5,C6:C20)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MEDIAN(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the median value."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "MIN": {
    "header": "MIN",
    "headerDescription": "Returns the minimum value in a list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["MIN(A2:A100,B2:B100,4,26)", "MIN(1,2,3,4,5,C6:C20)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MIN(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the minimum value."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "MINA": {
    "header": "MINA",
    "headerDescription": "Returns the minimum value in a list of arguments.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["MINA(A2:A100,B2:B100,4,26)", "MINA(1,2,3,4,5,C6:C20)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MINA(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range to consider when calculating the minimum value."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "NEGBINOM.DIST": {
    "header": "NEGBINOM.DIST",
    "headerDescription": "Returns density of negative binomial distribution.",
    "type": "Statistical",
    "parameters": ["num_failures", "num_successes", "prob_success"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "NEGBINOMDIST": {
    "header": "NEGBINOMDIST",
    "headerDescription": "Returns density of negative binomial distribution.",
    "type": "Statistical",
    "parameters": ["num_failures", "num_successes", "prob_success"],
    "codeSyntaxUsage": ["NEGBINOMDIST(4,2,0.1)", "NEGBINOMDIST(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NEGBINOMDIST(num_failures, num_successes, prob_success)",
        "values": [
          {
            "syntaxName": "num_failures",
            "description": "The number of failures to model."
          },
          {
            "syntaxName": "num_successes",
            "description": "The number of successes to model."
          },
          {
            "syntaxName": "prob_success",
            "description": "The probability of success in any given trial."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NORM.DIST": {
    "header": "NORM.DIST",
    "headerDescription": "Returns density of normal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "NORMDIST": {
    "header": "NORMDIST",
    "headerDescription": "Returns density of normal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation", "cumulative"],
    "codeSyntaxUsage": ["NORMDIST(2.4,1,4,FALSE)", "NORMDIST(A2,A3,A4,TRUE)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NORMDIST(x, mean, standard_deviation, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the normal distribution function."
          },
          {
            "syntaxName": "mean",
            "description": "The mean (mu) of the normal distribution function."
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation (sigma) of the normal distribution function."
          },
          {
            "syntaxName": "cumulative",
            "description": "Whether to use the normal cumulative distribution function rather than the distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NORM.S.DIST": {
    "header": "NORM.S.DIST",
    "headerDescription": "Returns density of normal distribution.",
    "type": "Statistical",
    "parameters": ["x"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "NORM.INV": {
    "header": "NORM.INV",
    "headerDescription": "Returns value of inverse normal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "NORMINV": {
    "header": "NORMINV",
    "headerDescription": "Returns value of inverse normal distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "standard_deviation"],
    "codeSyntaxUsage": ["NORMINV(.75,1,4)", "NORMINV(A2,A3,A4)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NORMINV(x, mean, standard_deviation)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the normal distribution function."
          },
          {
            "syntaxName": "mean",
            "description": "The mean (mu) of the normal distribution function."
          },
          {
            "syntaxName": "standard_deviation",
            "description": "The standard deviation (sigma) of the normal distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "NORM.S.INV": {
    "header": "NORM.S.INV",
    "headerDescription": "Returns value of inverse normal distribution.",
    "type": "Statistical",
    "parameters": ["x"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "NORMSINV": {
    "header": "NORMSINV",
    "headerDescription": "Returns value of inverse normal distribution.",
    "type": "Statistical",
    "parameters": ["x"],
    "codeSyntaxUsage": ["NORMSINV(.75)", "NORMSINV(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "NORMSINV(x)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the inverse standard normal distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "PEARSON": {
    "header": "PEARSON",
    "headerDescription": "Returns the correlation coefficient between two data sets.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["PEARSON(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PEARSON(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "PHI": {
    "header": "PHI",
    "headerDescription": "Returns probability densitity of normal distribution.",
    "type": "Statistical",
    "parameters": ["x"],
    "codeSyntaxUsage": ["PHI(0.25)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PHI(x)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the standard normal distribution function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "POISSON": {
    "header": "POISSON",
    "headerDescription": "Returns density of Poisson distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "POISSON.DIST": {
    "header": "POISSON.DIST",
    "headerDescription": "Returns density of Poisson distribution.",
    "type": "Statistical",
    "parameters": ["x", "mean", "[cumulative]"],
    "codeSyntaxUsage": [
      "POISSON.DIST(2.4,1,FALSE)",
      "POISSON.DIST(A2,A3,TRUE)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "POISSON.DIST(x, mean, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the Poisson distribution function."
          },
          {
            "syntaxName": "mean",
            "description": "The mean (mu) of the Poisson distribution function."
          },
          {
            "syntaxName": "cumulative",
            "description": "Whether to use the Poisson cumulative distribution function rather than the distribution function.."
          }
        ]
      }
    ],
    "attributes": []
  },
  "RSQ": {
    "header": "RSQ",
    "headerDescription": "Returns the squared correlation coefficient between two data sets.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["RSQ(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RSQ(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SKEW": {
    "header": "SKEW",
    "headerDescription": "Returns skeweness of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["SKEW(1,2,3,4,5,6,7,8,9,10)", "SKEW(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SKEW(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the data set."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the data set."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SKEW.P": {
    "header": "SKEW.P",
    "headerDescription": "Returns skeweness of a population.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SKEW.P(value1, value2)",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the data set."
          },
          {
            "syntaxName": "value2",
            "description": "Additional values or ranges to include in the data set. "
          }
        ]
      }
    ],
    "attributes": []
  },
  "SLOPE": {
    "header": "SLOPE",
    "headerDescription": "Returns the slope of a linear regression line.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["SLOPE(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SLOPE(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "SMALL": {
    "header": "SMALL",
    "headerDescription": "Returns k-th smallest value in a range.",
    "type": "Statistical",
    "parameters": ["data", "n"],
    "codeSyntaxUsage": ["SMALL(A2:B100,4)", "SMALL(A2:B100,C2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SMALL(data, n)",
        "values": [
          {
            "syntaxName": "data",
            "description": "The array or range containing the data set to consider."
          },
          {
            "syntaxName": "n",
            "description": "The rank from smallest to largest of the element to return.          For example, setting n to 4 will cause SMALL to return the 4th smallest element from data."
          },
          {
            "syntaxName": "For example, setting n to 4 will cause SMALL to return the 4th smallest element from data.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "STANDARDIZE": {
    "header": "STANDARDIZE",
    "headerDescription": "Returns normalized value wrt expected value and standard deviation.",
    "type": "Statistical",
    "parameters": ["value", "mean", "standard_deviation"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "STDEV": {
    "header": "STDEV",
    "headerDescription": "Returns standard deviation of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["STDEV(1,2,3,4,5,6,7,8,9,10)", "STDEV(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "STDEV(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          { "syntaxName": "value2, …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "STDEVA": {
    "header": "STDEVA",
    "headerDescription": "Returns standard deviation of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["STDEVA(1,2,3,4,5,6,7,8,9,10)", "STDEVA(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "STDEVA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the sample."
          }
        ]
      }
    ],
    "attributes": []
  },
  "STDEVP": {
    "header": "STDEVP",
    "headerDescription": "Returns standard deviation of a population.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["STDEVP(1,2,3,4,5,6,7,8,9,10)", "STDEVP(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "STDEVP(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "STDEV.P": {
    "header": "STDEV.P",
    "headerDescription": "Returns standard deviation of a population.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "STDEVPA": {
    "header": "STDEVPA",
    "headerDescription": "Returns standard deviation of a population.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["STDEVPA(1,2,3,4,5,6,7,8,9,10)", "STDEVPA(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "STDEVPA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "STDEV.S": {
    "header": "STDEV.S",
    "headerDescription": "Returns standard deviation of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "STEYX": {
    "header": "STEYX",
    "headerDescription": "Returns standard error for predicted of the predicted y value for each x value.",
    "type": "Statistical",
    "parameters": ["data_y", "data_x"],
    "codeSyntaxUsage": ["STEYX(A2:A100,B2:B100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "STEYX(data_y, data_x)",
        "values": [
          {
            "syntaxName": "data_y",
            "description": "The range representing the array or matrix of dependent data."
          },
          {
            "syntaxName": "data_x",
            "description": "The range representing the array or matrix of independent data."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TDIST": {
    "header": "TDIST",
    "headerDescription": "Returns density of Student-t distribution, both-sided or right-tailed.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom", "tails"],
    "codeSyntaxUsage": ["TDIST(A2, 30, 1)", "TDIST(0.5, 1, 2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TDIST(x, degrees_freedom, tails)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the t-distribution function."
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "The number of degrees of freedom."
          },
          {
            "syntaxName": "tails",
            "description": "Specifies whether the calculated distribution will be one- or two-sided. (1 for one-tailed distributions, 2 for two-tailed distributions)."
          }
        ]
      }
    ],
    "attributes": []
  },
  "T.DIST": {
    "header": "T.DIST",
    "headerDescription": "Returns density of Student-t distribution.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom", "cumulative"],
    "codeSyntaxUsage": ["A1 has T.DIST(1.96, 60, false)  Example 2"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.DIST(x, degrees_freedom, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "Required. The x value to evaluate the distribution at."
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "Required. The degrees of freedom."
          },
          {
            "syntaxName": "cumulative",
            "description": "Required. True/false value field. If true, returns the cumulative probability for x. If false, returns the probability density function for x."
          }
        ]
      }
    ],
    "attributes": []
  },
  "T.DIST.2T": {
    "header": "T.DIST.2T",
    "headerDescription": "Returns density of Student-t distribution, both-sided.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom"],
    "codeSyntaxUsage": ["T.DIST.2T(1.96, 60)", "T.DIST.2T(1, 2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.DIST.2T(x, degrees_freedom)",
        "values": [
          {
            "syntaxName": "x",
            "description": "Required. The x value to evaluate the distribution at."
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "Required. The degrees of freedom."
          }
        ]
      }
    ],
    "attributes": []
  },
  "T.DIST.RT": {
    "header": "T.DIST.RT",
    "headerDescription": "Returns density of Student-t distribution, right-tailed.",
    "type": "Statistical",
    "parameters": ["x", "degrees_freedom"],
    "codeSyntaxUsage": ["A1 has T.DIST.RT(1.96, 60)  Example 2"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.DIST.2T(x, degrees_freedom)",
        "values": [
          {
            "syntaxName": "x",
            "description": "Required. The x value to evaluate the distribution at."
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "Required. The degrees of freedom."
          }
        ]
      }
    ],
    "attributes": []
  },
  "TINV": {
    "header": "TINV",
    "headerDescription": "Returns inverse Student-t distribution, both-sided.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "T.INV": {
    "header": "T.INV",
    "headerDescription": "Returns inverse Student-t distribution.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": ["T.INV(0.35, 1)", "T.INV(A1, A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.INV(probability, degrees_freedom)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "the probability associated with the t-distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "the number of degrees of freedom.                  Truncated to an integer in the calculation if a non-integer is provided as an argument.                    Must be greater than or equal to 1."
          },
          {
            "syntaxName": "Truncated to an integer in the calculation if a non-integer is provided as an argument.",
            "description": ""
          },
          {
            "syntaxName": "Must be greater than or equal to 1.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "T.INV.2T": {
    "header": "T.INV.2T",
    "headerDescription": "Returns inverse Student-t distribution, both-sided.",
    "type": "Statistical",
    "parameters": ["probability", "degrees_freedom"],
    "codeSyntaxUsage": ["T.INV.2T(0.35, 1)", "T.INV.2T(A1, A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.INV.2T(probability, degrees_freedom)",
        "values": [
          {
            "syntaxName": "probability",
            "description": "The probability associated with the two-tailed t-distribution.                  Must be greater than 0 and less than 1."
          },
          {
            "syntaxName": "Must be greater than 0 and less than 1.",
            "description": ""
          },
          {
            "syntaxName": "degrees_freedom",
            "description": "the number of degrees of freedom.                  Truncated to an integer in the calculation if a non-integer is provided as an argument.                    Must be greater than or equal to 1."
          },
          {
            "syntaxName": "Truncated to an integer in the calculation if a non-integer is provided as an argument.",
            "description": ""
          },
          {
            "syntaxName": "Must be greater than or equal to 1.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "TTEST": {
    "header": "TTEST",
    "headerDescription": "Returns t-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["range1", "range2", "tails", "type"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "T.TEST": {
    "header": "T.TEST",
    "headerDescription": "Returns t-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["range1", "range2", "tails", "type"],
    "codeSyntaxUsage": ["T.TEST(A1:A4, B1:B4, 2, 1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T.TEST(range1, range2, tails, type)",
        "values": [
          {
            "syntaxName": "range1",
            "description": "the first sample of data or group of cells to consider for the t-test."
          },
          {
            "syntaxName": "range2",
            "description": "the second sample of data or group of cells to consider for the t-test."
          },
          {
            "syntaxName": "tails",
            "description": "specifies the number of distribution tails.                  If 1: uses a one-tailed distribution.                    If 2: uses a two-tailed distribution."
          },
          {
            "syntaxName": "If 1: uses a one-tailed distribution.",
            "description": ""
          },
          {
            "syntaxName": "If 2: uses a two-tailed distribution.",
            "description": ""
          },
          {
            "syntaxName": "type",
            "description": "specifies the type of t-Test.                  If 1: a paired test is performed.                    If 2: a two-sample equal variance (homoscedastic) test is performed.                    If 3: a two-sample unequal variance (heteroscedastic) test is performed."
          },
          {
            "syntaxName": "If 1: a paired test is performed.",
            "description": ""
          },
          {
            "syntaxName": "If 2: a two-sample equal variance (homoscedastic) test is performed.",
            "description": ""
          },
          {
            "syntaxName": "If 3: a two-sample unequal variance (heteroscedastic) test is performed.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "VAR": {
    "header": "VAR",
    "headerDescription": "Returns variance of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": ["VAR(1,2,3,4,5,6,7,8,9,10)", "VAR(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "VAR(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the sample."
          }
        ]
      }
    ],
    "attributes": []
  },
  "VARA": {
    "header": "VARA",
    "headerDescription": "Returns variance of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["VARA(1,2,3,4,5,6,7,8,9,10)", "VARA(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "VARA(value1, [value2, ...])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the sample."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the sample."
          }
        ]
      }
    ],
    "attributes": []
  },
  "VARP": {
    "header": "VARP",
    "headerDescription": "Returns variance of a population.",
    "type": "Statistical",
    "parameters": ["value1", "value2"],
    "codeSyntaxUsage": ["VARP(1,2,3,4,5,6,7,8,9,10)", "VARP(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "VARP(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "VAR.P": {
    "header": "VAR.P",
    "headerDescription": "Returns variance of a population.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "VARPA": {
    "header": "VARPA",
    "headerDescription": "Returns variance of a population.",
    "type": "Statistical",
    "parameters": ["value1", "value2", ".."],
    "codeSyntaxUsage": ["VARPA(1,2,3,4,5,6,7,8,9,10)", "VARPA(A2:A100)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "VARPA(value1, [value2, …])",
        "values": [
          {
            "syntaxName": "value1",
            "description": "The first value or range of the population."
          },
          {
            "syntaxName": "value2, ...",
            "description": "Additional values or ranges to include in the population."
          }
        ]
      }
    ],
    "attributes": []
  },
  "VAR.S": {
    "header": "VAR.S",
    "headerDescription": "Returns variance of a sample.",
    "type": "Statistical",
    "parameters": ["value1", "[value2, ..]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "WEIBULL": {
    "header": "WEIBULL",
    "headerDescription": "Returns density of Weibull distribution.",
    "type": "Statistical",
    "parameters": ["x", "shape", "scale", "cumulative"],
    "codeSyntaxUsage": ["WEIBULL(2.4, 2, 3, TRUE)", "WEIBULL(A2,A3,A4,TRUE)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "WEIBULL(x, shape, scale, cumulative)",
        "values": [
          {
            "syntaxName": "x",
            "description": "The input to the Weibull distribution function."
          },
          {
            "syntaxName": "shape",
            "description": "The shape parameter of the Weibull distribution function.                  shape is usually denoted as k and denoted as alpha in other spreadsheet packages.                    shape must be greater than 0."
          },
          {
            "syntaxName": "shape is usually denoted as k and denoted as alpha in other spreadsheet packages.",
            "description": ""
          },
          { "syntaxName": "shape must be greater than 0.", "description": "" },
          {
            "syntaxName": "scale",
            "description": "The scale parameter of the Weibull distribution function.                  scale is usually denoted as lambda in texts and denoted as beta in other spreadsheet packages.                    scale must be greater than 0."
          },
          {
            "syntaxName": "scale is usually denoted as lambda in texts and denoted as beta in other spreadsheet packages.",
            "description": ""
          },
          { "syntaxName": "scale must be greater than 0.", "description": "" },
          {
            "syntaxName": "cumulative",
            "description": "TRUE to use the cumulative distribution function, FALSE to use the probability density function."
          }
        ]
      }
    ],
    "attributes": []
  },
  "WEIBULL.DIST": {
    "header": "WEIBULL.DIST",
    "headerDescription": "Returns density of Weibull distribution.",
    "type": "Statistical",
    "parameters": ["x", "shape", "scale", "cumulative"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "Z.TEST": {
    "header": "Z.TEST",
    "headerDescription": "Returns z-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["data", "value", "[standard_deviation]"],
    "codeSyntaxUsage": ["Z.TEST(A2:A100,B2)", "Z.TEST({1,2,3,4,5,6},5.5,1.2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "Z.TEST(data, value, [standard_deviation])",
        "values": [
          {
            "syntaxName": "data",
            "description": "The array or range containing the data set to consider."
          },
          {
            "syntaxName": "value - The test statistic to use in the z-test.",
            "description": ""
          },
          {
            "syntaxName": "standard_deviation",
            "description": "[ OPTIONAL ] - The standard deviation to assume for the z-test. If this is not provided, STDEV(data) will be calculated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "ZTEST": {
    "header": "ZTEST",
    "headerDescription": "Returns z-test value for a dataset.",
    "type": "Statistical",
    "parameters": ["data", "value", "[standard_deviation]"],
    "codeSyntaxUsage": [],
    "codeSyntaxElements": [],
    "attributes": []
  },
  "CHAR": {
    "header": "CHAR",
    "headerDescription": "Converts a number into a character according to the current code table.",
    "type": "Text",
    "parameters": ["table_number"],
    "codeSyntaxUsage": ["CHAR(97)", "CHAR(HEX2DEC('A3'))", "CHAR(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CHAR(table_number)",
        "values": [
          {
            "syntaxName": "table_number",
            "description": "The number of the character to look up from the current Unicode table in decimal format.          table_number must be a number in decimal format (base 10). Many tables provide Unicode values in hexadecimal format (base 16). In this case, use the HEX2DEC function to convert."
          },
          {
            "syntaxName": "table_number must be a number in decimal format (base 10). Many tables provide Unicode values in hexadecimal format (base 16). In this case, use the HEX2DEC function to convert.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "CLEAN": {
    "header": "CLEAN",
    "headerDescription": "Returns text that has been \"cleaned\" of line breaks and other non-printable characters.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": ["CLEAN(\"\"AF\"\"&CHAR(31))"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CLEAN(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The text whose non-printable characters are to be removed."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CODE": {
    "header": "CODE",
    "headerDescription": "Returns a numeric code for the first character in a text string.",
    "type": "Text",
    "parameters": ["string"],
    "codeSyntaxUsage": ["CODE(\"\"a\"\")", "CODE(A1)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CODE(string)",
        "values": [
          {
            "syntaxName": "string",
            "description": "The string whose first character's Unicode map value will be returned."
          }
        ]
      }
    ],
    "attributes": []
  },
  "CONCATENATE": {
    "header": "CONCATENATE",
    "headerDescription": "Combines several text strings into one string.",
    "type": "Text",
    "parameters": ["string1", "[string2, ..]"],
    "codeSyntaxUsage": [
      "CONCATENATE('Welcome', ' ', 'to', ' ', 'Sheets')",
      "CONCATENATE(A1,A2,A3)",
      "CONCATENATE(A2:B7)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "CONCATENATE(string1, [string2, ...])",
        "values": [
          { "syntaxName": "string1", "description": "The initial string." },
          { "syntaxName": "string2 …", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "EXACT": {
    "header": "EXACT",
    "headerDescription": "Returns TRUE if both text strings are exactly the same.",
    "type": "Text",
    "parameters": ["string1", "string2"],
    "codeSyntaxUsage": ["EXACT(A1,A2)", "EXACT(\"\"foo\"\",A3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "`EXACT(string1, string2)",
        "values": [
          {
            "syntaxName": "string1",
            "description": "The first string to compare"
          },
          {
            "syntaxName": "string2",
            "description": "The second string to compare"
          }
        ]
      }
    ],
    "attributes": []
  },
  "FIND": {
    "header": "FIND",
    "headerDescription": "Returns the location of one text string inside another.",
    "type": "Text",
    "parameters": ["search_for", "text_to_search", "[starting_at]"],
    "codeSyntaxUsage": [
      "FIND(\"\"n\"\",A2)",
      "FIND(\"\"wood\"\",\"\"How much wood can a woodchuck chuck\"\",14)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "FIND(search_for, text_to_search, [starting_at])",
        "values": [
          {
            "syntaxName": "search_for",
            "description": "The string to look for within text_to_search."
          },
          {
            "syntaxName": "text_to_search",
            "description": "The text to search for the first occurrence of search_for."
          },
          { "syntaxName": "starting_at", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "LEFT": {
    "header": "LEFT",
    "headerDescription": "Extracts a given number of characters from the left side of a text string.",
    "type": "Text",
    "parameters": ["string", "[number_of_characters]"],
    "codeSyntaxUsage": ["LEFT(A2,2)", "LEFT('lorem ipsum')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LEFT(string, [number_of_characters])",
        "values": [
          {
            "syntaxName": "string",
            "description": "The string from which the left portion will be returned."
          },
          { "syntaxName": "number_of_characters", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "LEN": {
    "header": "LEN",
    "headerDescription": "Returns length of a given text.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": ["LEN(A2)", "LEN('lorem ipsum')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LEN(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The string for which the length will be returned."
          }
        ]
      }
    ],
    "attributes": []
  },
  "LOWER": {
    "header": "LOWER",
    "headerDescription": "Returns text converted to lowercase.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": ["LOWER(\"\"LOREM IPSUM\"\")", "LOWER(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "LOWER(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The string to convert to lowercase."
          }
        ]
      }
    ],
    "attributes": []
  },
  "MID": {
    "header": "MID",
    "headerDescription": "Returns substring of a given length starting from Start_position.",
    "type": "Text",
    "parameters": ["string", "starting_at", "extract_length"],
    "codeSyntaxUsage": ["MID(\"\"get this\"\",5,4)", "MID(A2,3,5)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "MID(string, starting_at, extract_length)",
        "values": [
          {
            "syntaxName": "string",
            "description": "The string to extract a segment from."
          },
          {
            "syntaxName": "starting_at",
            "description": "The index from the left of string from which to begin extracting. The first character in string has the index 1."
          },
          {
            "syntaxName": "extract_length",
            "description": "The length of the segment to extract.          If the end of string is reached before extract_length characters are encountered, MID returns the characters from starting_at to the end of string."
          },
          {
            "syntaxName": "If the end of string is reached before extract_length characters are encountered, MID returns the characters from starting_at to the end of string.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "PROPER": {
    "header": "PROPER",
    "headerDescription": "Capitalizes words given text string.",
    "type": "Text",
    "parameters": ["text_to_capitalize"],
    "codeSyntaxUsage": ["PROPER(\"\"united states\"\")", "PROPER(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "PROPER(text_to_be_capitalised)",
        "values": [
          {
            "syntaxName": "text_to_be_capitalised",
            "description": "The text which will be returned with the first letter of each word in uppercase and all other letters in lowercase."
          }
        ]
      }
    ],
    "attributes": []
  },
  "REPLACE": {
    "header": "REPLACE",
    "headerDescription": "Replaces substring of a text of a given length that starts at given position.",
    "type": "Text",
    "parameters": ["text", "position", "length", "new_text"],
    "codeSyntaxUsage": ["REPLACE(\"\"Spreadsheets\"\", 1, 6, \"\"Bed\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "REPLACE(text, position, length, new_text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The text, a part of which will be replaced."
          },
          {
            "syntaxName": "position",
            "description": "The position where the replacement will begin (starting from 1)."
          },
          {
            "syntaxName": "length",
            "description": "The number of characters in the text to be replaced."
          },
          {
            "syntaxName": "new_text",
            "description": "The text that will be inserted into the original text."
          }
        ]
      }
    ],
    "attributes": []
  },
  "REPT": {
    "header": "REPT",
    "headerDescription": "Repeats text a given number of times.",
    "type": "Text",
    "parameters": ["text_to_repeat", "number_of_repetitions"],
    "codeSyntaxUsage": ["REPT(\"\"ha\"\",4)", "REPT(A2,3)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "REPT(text_to_be_repeated, number_of_repetitions)",
        "values": [
          {
            "syntaxName": "text_to_be_repeated",
            "description": "The character or string to be repeated."
          },
          {
            "syntaxName": "number_of_repetitions",
            "description": "The number of times that text_to_be_repeated should appear in the value returned.          The number_of_repetitions can’t exceed the character limit of a cell: 32,000 characters. If number_of_repetitions is greater than 32,000 characters, REPT will return a #VALUE! error."
          },
          {
            "syntaxName": "The number_of_repetitions can’t exceed the character limit of a cell: 32,000 characters. If number_of_repetitions is greater than 32,000 characters, REPT will return a #VALUE! error.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "RIGHT": {
    "header": "RIGHT",
    "headerDescription": "Extracts a given number of characters from the right side of a text string.",
    "type": "Text",
    "parameters": ["string", "[number_of_characters]"],
    "codeSyntaxUsage": ["RIGHT(A2,2)", "RIGHT('lorem ipsum')"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "RIGHT(string, [number_of_characters])",
        "values": [
          {
            "syntaxName": "string",
            "description": "The string from which the right portion will be returned."
          },
          { "syntaxName": "number_of_characters", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "SEARCH": {
    "header": "SEARCH",
    "headerDescription": "Returns the location of one text string inside another. (Allows the use of wildcards.)",
    "type": "Text",
    "parameters": ["search_for", "text_to_search", "[starting_at]"],
    "codeSyntaxUsage": [
      "SEARCH(\"\"n\"\",A2)",
      "SEARCH(\"\"wood\"\",\"\"How much wood can a woodchuck chuck\"\",14)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SEARCH(search_for, text_to_search, [starting_at])",
        "values": [
          {
            "syntaxName": "search_for",
            "description": "The string to look for within text_to_search."
          },
          {
            "syntaxName": "text_to_search",
            "description": "The text to be searched for the first occurrence of search_for."
          },
          { "syntaxName": "starting_at", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "SPLIT": {
    "header": "SPLIT",
    "headerDescription": "Divides text around a specified character or string, and puts each fragment into a separate cell in the row.",
    "type": "Text",
    "parameters": [
      "text",
      "delimiter",
      "[split_by_each]",
      "[remove_empty_text]"
    ],
    "codeSyntaxUsage": [
      "SPLIT(\"\"1,2,3\"\", \"\",\"\")",
      "SPLIT(\"\"Alas, poor Yorick\"\",\"\" \"\")",
      "SPLIT(A1, \"\",\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SPLIT(text, delimiter, [split_by_each], [remove_empty_text])",
        "values": [
          { "syntaxName": "text", "description": "The text to be divided." },
          {
            "syntaxName": "delimiter",
            "description": "The character or characters to be used to split text.          By default, each character in delimiter is considered individually, e.g. if delimiter is 'the', then text is divided around the characters 't', 'h' and 'e'. Set split_by_each to FALSE to turn off this behaviour."
          },
          {
            "syntaxName": "By default, each character in delimiter is considered individually, e.g. if delimiter is 'the', then text is divided around the characters 't', 'h' and 'e'. Set split_by_each to FALSE to turn off this behaviour.",
            "description": ""
          },
          { "syntaxName": "split_by_each", "description": "[ OPTIONAL" },
          { "syntaxName": "remove_empty_text", "description": "[ OPTIONAL" }
        ]
      }
    ],
    "attributes": []
  },
  "SUBSTITUTE": {
    "header": "SUBSTITUTE",
    "headerDescription": "Returns string where occurrences of Old_text are replaced by New_text. Replaces only specific occurrence if last parameter is provided.",
    "type": "Text",
    "parameters": [
      "text_to_search",
      "search_for",
      "replace_with",
      "[occurrence_number]"
    ],
    "codeSyntaxUsage": [
      "SUBSTITUTE(\"\"search for it\"\",\"\"search for\"\",\"\"Google\"\")",
      "SUBSTITUTE(A2,\"\"new york\"\",\"\"New York\"\")",
      "SUBSTITUTE(\"\"January 2, 2012\"\",2,3,1)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "SUBSTITUTE(text_to_search, search_for, replace_with, [occurrence_number])",
        "values": [
          {
            "syntaxName": "text_to_search",
            "description": "The text within which to search and replace."
          },
          {
            "syntaxName": "search_for",
            "description": "The string to search for within text_to_search.          search_for will match parts of words as well as whole words; therefore, a search for 'vent' will also replace text within 'eventual'."
          },
          {
            "syntaxName": "search_for will match parts of words as well as whole words; therefore, a search for 'vent' will also replace text within 'eventual'.",
            "description": ""
          },
          {
            "syntaxName": "replace_with",
            "description": "The string that will replace search_for."
          },
          { "syntaxName": "occurrence_number", "description": "[ OPTIONAL ]" }
        ]
      }
    ],
    "attributes": []
  },
  "T": {
    "header": "T",
    "headerDescription": "Returns text if given value is text, empty string otherwise.",
    "type": "Text",
    "parameters": ["value"],
    "codeSyntaxUsage": ["T(A2)", "T(\"\"cat\"\")"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "T(value)",
        "values": [
          {
            "syntaxName": "value",
            "description": "The argument to be converted to text.                  If value is text, T returns value.                    If value is a reference to a cell containing text, T returns the contents of value.                    If value is an error or a cell containing an error, T returns the error.                    Otherwise, T returns an empty string."
          },
          {
            "syntaxName": "If value is text, T returns value.",
            "description": ""
          },
          {
            "syntaxName": "If value is a reference to a cell containing text, T returns the contents of value.",
            "description": ""
          },
          {
            "syntaxName": "If value is an error or a cell containing an error, T returns the error.",
            "description": ""
          },
          {
            "syntaxName": "Otherwise, T returns an empty string.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "TEXT": {
    "header": "TEXT",
    "headerDescription": "Converts a number into text according to a given format.",
    "type": "Text",
    "parameters": ["number", "format"],
    "codeSyntaxUsage": [
      "TEXT(1.23,\"\"$0.00\"\")",
      "TEXT(A2,\"\"#.###\"\")",
      "TEXT(24,\"\"#.0?\"\")",
      "TEXT(DATE(1969,7,20),\"\"MM-yyyy\"\")"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TEXT(number, format)",
        "values": [
          {
            "syntaxName": "number",
            "description": "The number, date or time to format."
          },
          {
            "syntaxName": "format",
            "description": "The pattern by which to format the number, enclosed in quotation marks.                  0 forces display of zeros if a number has fewer digits than the format specified. For example, TEXT(12.3,\"\"000.00\"\") produces 012.30. Numbers that have more digits to the right of the decimal point than the pattern are rounded to the indicated number of places. For example, TEXT(12.305,\"\"00.00\"\") results in 12.31.                    # is similar to 0 but does not force the display of zeros on either side of the decimal point. For example, TEXT(12.3,\"\"###.##\"\") produces 12.3."
          },
          {
            "syntaxName": "0 forces display of zeros if a number has fewer digits than the format specified. For example, TEXT(12.3,\"\"000.00\"\") produces 012.30. Numbers that have more digits to the right of the decimal point than the pattern are rounded to the indicated number of places. For example, TEXT(12.305,\"\"00.00\"\") results in 12.31.",
            "description": ""
          },
          {
            "syntaxName": "# is similar to 0 but does not force the display of zeros on either side of the decimal point. For example, TEXT(12.3,\"\"###.##\"\") produces 12.3.",
            "description": ""
          }
        ]
      }
    ],
    "attributes": []
  },
  "TRIM": {
    "header": "TRIM",
    "headerDescription": "Strips extra spaces from text.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": ["TRIM(\"\" lorem ipsum\"\")", "TRIM(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "TRIM(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The string or reference to a cell containing a string to be trimmed."
          }
        ]
      }
    ],
    "attributes": []
  },
  "UNICHAR": {
    "header": "UNICHAR",
    "headerDescription": "Returns the character created by using provided code point.",
    "type": "Text",
    "parameters": ["number"],
    "codeSyntaxUsage": [
      "UNICHAR(68) returns D",
      "UNICHAR(307) returns \\u0133, which may appear as ĳ"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "UNICHAR(number)",
        "values": [
          {
            "syntaxName": "number",
            "description": "Required. The number to convert into a Unicode character. The number should be greater than 0."
          }
        ]
      }
    ],
    "attributes": []
  },
  "UNICODE": {
    "header": "UNICODE",
    "headerDescription": "Returns the Unicode code point of a first character of a text.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": [
      "UNICODE(\"\"A\"\")",
      "UNICODE(123)",
      "UNICODE(😀😀😄)"
    ],
    "codeSyntaxElements": [
      {
        "codeSyntax": "UNICODE(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The string containing the character to be evaluated."
          }
        ]
      }
    ],
    "attributes": []
  },
  "UPPER": {
    "header": "UPPER",
    "headerDescription": "Returns text converted to uppercase.",
    "type": "Text",
    "parameters": ["text"],
    "codeSyntaxUsage": ["UPPER(\"\"lorem ipsum\"\")", "UPPER(A2)"],
    "codeSyntaxElements": [
      {
        "codeSyntax": "UPPER(text)",
        "values": [
          {
            "syntaxName": "text",
            "description": "The string to be converted to uppercase."
          }
        ]
      }
    ],
    "attributes": []
  }
}
